//! Process management with PTY support
//!
//! Manages terminal process lifecycle including spawning, monitoring, and cleanup.
//! Uses portable-pty for cross-platform PTY support (Windows ConPTY, Unix PTY).

use std::{
    collections::HashMap,
    io::{Read, Write},
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
    time::Duration,
};

use db::DBService;
use portable_pty::{Child, CommandBuilder, MasterPty, PtySize, native_pty_system};
use tokio::{
    sync::{Mutex as AsyncMutex, RwLock, oneshot},
    task::JoinHandle,
};
use uuid::Uuid;

use super::{
    output_fanout::{OutputFanout, OutputFanoutConfig, OutputSubscription},
    utf8_decoder::Utf8StreamDecoder,
};

// ============================================================================
// PTY Size Configuration
// ============================================================================

/// Default terminal columns
pub const DEFAULT_COLS: u16 = 80;

/// Default terminal rows
pub const DEFAULT_ROWS: u16 = 24;

/// Reader buffer size for background PTY output fanout
pub const PROCESS_PTY_READ_BUFFER_SIZE: usize = 4096;

/// Default replay chunk retention per terminal stream
pub const PROCESS_REPLAY_MAX_CHUNKS: usize = 512;

/// Default replay byte retention per terminal stream
pub const PROCESS_REPLAY_MAX_BYTES: usize = 1024 * 1024;

/// Graceful shutdown timeout for PTY reader task
const READER_SHUTDOWN_TIMEOUT_SECS: u64 = 1;

/// Graceful shutdown timeout for terminal logger task
const LOGGER_SHUTDOWN_TIMEOUT_SECS: u64 = 2;

// ============================================================================
// Spawn Configuration (Process Isolation)
// ============================================================================

/// Environment variable configuration for process-level isolation.
///
/// Supports both setting new environment variables and removing inherited ones
/// to prevent parent process pollution.
#[derive(Debug, Clone, Default)]
pub struct SpawnEnv {
    /// Environment variables to set on the child process.
    pub set: HashMap<String, String>,
    /// Environment variable keys to remove from the inherited environment.
    /// Use this to prevent parent process environment from leaking into child.
    pub unset: Vec<String>,
}

impl SpawnEnv {
    /// Creates a new empty SpawnEnv.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds an environment variable to set.
    pub fn with_var(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.set.insert(key.into(), value.into());
        self
    }

    /// Adds an environment variable key to unset (remove from inherited env).
    pub fn with_unset(mut self, key: impl Into<String>) -> Self {
        self.unset.push(key.into());
        self
    }

    /// Checks if an environment variable key contains sensitive information.
    /// Used for log redaction.
    pub fn is_sensitive_key(key: &str) -> bool {
        let key_upper = key.to_ascii_uppercase();
        key_upper.contains("KEY")
            || key_upper.contains("TOKEN")
            || key_upper.contains("SECRET")
            || key_upper.contains("PASSWORD")
            || key_upper.contains("CREDENTIAL")
    }
}

/// Command configuration for spawning terminal processes.
///
/// Encapsulates all information needed to spawn a process with proper isolation:
/// command, arguments, working directory, and environment configuration.
#[derive(Debug, Clone)]
pub struct SpawnCommand {
    /// Command to execute (e.g., "claude", "codex", "gemini").
    pub command: String,
    /// Command-line arguments.
    pub args: Vec<String>,
    /// Working directory for the child process.
    pub working_dir: PathBuf,
    /// Environment variable configuration for process isolation.
    pub env: SpawnEnv,
}

impl SpawnCommand {
    /// Creates a new SpawnCommand with the given command and working directory.
    pub fn new(command: impl Into<String>, working_dir: impl Into<PathBuf>) -> Self {
        Self {
            command: command.into(),
            args: Vec::new(),
            working_dir: working_dir.into(),
            env: SpawnEnv::default(),
        }
    }

    /// Adds a command-line argument.
    pub fn with_arg(mut self, arg: impl Into<String>) -> Self {
        self.args.push(arg.into());
        self
    }

    /// Adds multiple command-line arguments.
    pub fn with_args(mut self, args: impl IntoIterator<Item = impl Into<String>>) -> Self {
        self.args.extend(args.into_iter().map(Into::into));
        self
    }

    /// Sets the environment configuration.
    pub fn with_env(mut self, env: SpawnEnv) -> Self {
        self.env = env;
        self
    }
}

// ============================================================================
// Process Handle Types
// ============================================================================

/// PTY reader wrapper for async reading
pub struct PtyReader(Box<dyn Read + Send>);

impl PtyReader {
    /// Read bytes from PTY (blocking)
    pub fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        self.0.read(buf)
    }
}

/// PTY writer wrapper for async writing
pub struct PtyWriter(Box<dyn Write + Send>);

impl PtyWriter {
    /// Write bytes to PTY (blocking)
    pub fn write_all(&mut self, buf: &[u8]) -> std::io::Result<()> {
        self.0.write_all(buf)
    }

    /// Flush PTY writer
    pub fn flush(&mut self) -> std::io::Result<()> {
        self.0.flush()
    }
}

/// Process handle for tracking spawned PTY processes
pub struct ProcessHandle {
    /// Process ID
    pub pid: u32,
    /// Unique session identifier
    pub session_id: String,
    /// Associated terminal ID
    pub terminal_id: String,
    /// PTY reader (for WebSocket forwarding) - single stream, no stdout/stderr separation
    pub reader: Option<PtyReader>,
    /// Shared PTY writer (for WebSocket input) - wrapped in Arc<Mutex> for reconnection support
    pub writer: Option<Arc<Mutex<PtyWriter>>>,
}

// Implement Debug manually since portable-pty types don't implement Debug
impl std::fmt::Debug for ProcessHandle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ProcessHandle")
            .field("pid", &self.pid)
            .field("session_id", &self.session_id)
            .field("terminal_id", &self.terminal_id)
            .field("reader", &self.reader.is_some())
            .field("writer", &self.writer.is_some())
            .finish()
    }
}

// ============================================================================
// Tracked Process
// ============================================================================

/// Tracked process with PTY master and child handles
struct TrackedProcess {
    /// Stable PTY session identifier for this terminal process lifecycle
    session_id: String,
    /// Child process for lifecycle management
    child: Box<dyn Child + Send + Sync>,
    /// PTY master for I/O and resize operations (wrapped in Mutex for Sync)
    master: Mutex<Box<dyn MasterPty + Send>>,
    /// Shared PTY writer (initialized on first get_handle call, then reused for reconnections)
    shared_writer: Option<Arc<Mutex<PtyWriter>>>,
    /// Isolated CODEX_HOME path (for Codex terminals, cleaned up on exit)
    codex_home: Option<PathBuf>,
    /// Output fanout hub (single reader -> multi-subscriber)
    output_fanout: Arc<OutputFanout>,
    /// Background PTY reader task
    reader_task: Option<JoinHandle<()>>,
    /// Background terminal log persistence task
    logger_task: Option<JoinHandle<()>>,
    /// Shutdown signal for graceful terminal log task stop
    logger_shutdown_tx: Option<oneshot::Sender<()>>,
}

// ============================================================================
// CODEX_HOME Cleanup Guard (RAII)
// ============================================================================

/// Guard that ensures CODEX_HOME directories are cleaned up on early spawn failures.
/// Uses RAII pattern to guarantee cleanup even if spawn_pty_with_config returns early.
struct CodexHomeGuard {
    terminal_id: String,
    path: Option<PathBuf>,
}

impl CodexHomeGuard {
    fn new(terminal_id: &str, path: Option<PathBuf>) -> Self {
        Self {
            terminal_id: terminal_id.to_string(),
            path,
        }
    }

    /// Disarm the guard after successful process tracking.
    /// The CODEX_HOME will be cleaned up by TrackedProcess instead.
    fn disarm(&mut self) {
        self.path = None;
    }
}

impl Drop for CodexHomeGuard {
    fn drop(&mut self) {
        if let Some(path) = self.path.take() {
            ProcessManager::cleanup_codex_home(&self.terminal_id, &path);
        }
    }
}

// ============================================================================
// Process Manager
// ============================================================================

/// Process manager for terminal lifecycle with PTY support
pub struct ProcessManager {
    processes: Arc<RwLock<HashMap<String, TrackedProcess>>>,
}

impl ProcessManager {
    /// Creates a new ProcessManager instance
    pub fn new() -> Self {
        Self {
            processes: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Cleans up CODEX_HOME temporary directory for a terminated Codex terminal.
    ///
    /// Safety: Only removes directories under the gitcortex temp directory to prevent
    /// accidental deletion of user data.
    fn cleanup_codex_home(terminal_id: &str, codex_home: &Path) {
        if codex_home.as_os_str().is_empty() {
            return;
        }

        // Safety check: only clean up directories under our temp directory
        let base_dir = std::env::temp_dir().join("gitcortex");
        if !codex_home.starts_with(&base_dir) {
            tracing::warn!(
                terminal_id = %terminal_id,
                codex_home = %codex_home.display(),
                "Skipping CODEX_HOME cleanup: path is outside temp directory"
            );
            return;
        }

        match std::fs::remove_dir_all(codex_home) {
            Ok(()) => {
                tracing::info!(
                    terminal_id = %terminal_id,
                    codex_home = %codex_home.display(),
                    "Cleaned up CODEX_HOME directory"
                );
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    codex_home = %codex_home.display(),
                    "CODEX_HOME directory already removed"
                );
            }
            Err(e) => {
                tracing::warn!(
                    terminal_id = %terminal_id,
                    codex_home = %codex_home.display(),
                    error = %e,
                    "Failed to clean up CODEX_HOME directory"
                );
            }
        }
    }

    async fn finalize_terminated_process(&self, terminal_id: &str, mut tracked: TrackedProcess) {
        Self::stop_reader_task_gracefully(terminal_id, tracked.reader_task.take()).await;
        Self::stop_logger_task_gracefully(
            terminal_id,
            tracked.logger_shutdown_tx.take(),
            tracked.logger_task.take(),
        )
        .await;

        if let Some(codex_home) = tracked.codex_home.take() {
            Self::cleanup_codex_home(terminal_id, &codex_home);
        }
    }

    async fn stop_reader_task_gracefully(terminal_id: &str, task: Option<JoinHandle<()>>) {
        let Some(mut task) = task else {
            return;
        };

        match tokio::time::timeout(Duration::from_secs(READER_SHUTDOWN_TIMEOUT_SECS), &mut task)
            .await
        {
            Ok(join_result) => {
                if let Err(e) = join_result {
                    tracing::warn!(
                        terminal_id = %terminal_id,
                        error = %e,
                        "PTY reader task finished with join error"
                    );
                }
            }
            Err(_) => {
                task.abort();
                tracing::warn!(
                    terminal_id = %terminal_id,
                    timeout_secs = READER_SHUTDOWN_TIMEOUT_SECS,
                    "PTY reader task graceful shutdown timed out, aborted"
                );
            }
        }
    }

    async fn stop_logger_task_gracefully(
        terminal_id: &str,
        shutdown_tx: Option<oneshot::Sender<()>>,
        task: Option<JoinHandle<()>>,
    ) {
        if let Some(tx) = shutdown_tx {
            let _ = tx.send(());
        }

        let Some(mut task) = task else {
            return;
        };

        match tokio::time::timeout(Duration::from_secs(LOGGER_SHUTDOWN_TIMEOUT_SECS), &mut task)
            .await
        {
            Ok(join_result) => {
                if let Err(e) = join_result {
                    tracing::warn!(
                        terminal_id = %terminal_id,
                        error = %e,
                        "Terminal logger task finished with join error"
                    );
                }
            }
            Err(_) => {
                task.abort();
                tracing::warn!(
                    terminal_id = %terminal_id,
                    timeout_secs = LOGGER_SHUTDOWN_TIMEOUT_SECS,
                    "Terminal logger task graceful shutdown timed out, aborted"
                );
            }
        }
    }

    /// Spawn dedicated PTY reader task for output fanout.
    fn spawn_output_reader_task(
        terminal_id: &str,
        mut reader: PtyReader,
        output_fanout: Arc<OutputFanout>,
    ) -> JoinHandle<()> {
        let terminal_id = terminal_id.to_string();
        tokio::task::spawn_blocking(move || {
            let mut decoder = Utf8StreamDecoder::new();
            let mut buf = [0u8; PROCESS_PTY_READ_BUFFER_SIZE];

            loop {
                match reader.0.read(&mut buf) {
                    Ok(0) => {
                        // EOF reached - flush any pending incomplete UTF-8 tail
                        if let Some(tail_text) = decoder.flush_lossy_tail() {
                            let _ = output_fanout.publish(tail_text, 0);
                        }
                        tracing::debug!(
                            terminal_id = %terminal_id,
                            "Background PTY reader reached EOF"
                        );
                        break;
                    }
                    Ok(n) => {
                        let decoded = decoder.decode_chunk(&buf[..n]);
                        if !decoded.text.is_empty() || decoded.dropped_invalid_bytes > 0 {
                            let _ =
                                output_fanout.publish(decoded.text, decoded.dropped_invalid_bytes);
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            terminal_id = %terminal_id,
                            error = %e,
                            "Background PTY reader stopped with error"
                        );
                        break;
                    }
                }
            }
        })
    }

    /// Create default output fanout configuration.
    fn default_output_fanout() -> Arc<OutputFanout> {
        Arc::new(OutputFanout::new(OutputFanoutConfig {
            replay_max_chunks: PROCESS_REPLAY_MAX_CHUNKS,
            replay_max_bytes: PROCESS_REPLAY_MAX_BYTES,
            ..OutputFanoutConfig::default()
        }))
    }

    /// Spawns a new terminal process with PTY using SpawnCommand configuration.
    ///
    /// This method provides process-level isolation by:
    /// 1. Removing inherited environment variables (via `env.unset`)
    /// 2. Injecting custom environment variables (via `env.set`)
    /// 3. Passing CLI arguments for runtime configuration
    ///
    /// This approach avoids modifying global configuration files, enabling
    /// multiple workflows to run concurrently without conflicts.
    ///
    /// # Arguments
    ///
    /// * `terminal_id` - Unique identifier for this terminal session
    /// * `config` - Spawn configuration including command, args, working dir, and env
    /// * `cols` - Initial terminal width in columns
    /// * `rows` - Initial terminal height in rows
    ///
    /// # Returns
    ///
    /// Returns a `ProcessHandle` containing the PID and session ID.
    pub async fn spawn_pty_with_config(
        &self,
        terminal_id: &str,
        config: &SpawnCommand,
        cols: u16,
        rows: u16,
    ) -> anyhow::Result<ProcessHandle> {
        // Capture CODEX_HOME for cleanup on process exit (and on early failures via guard)
        let codex_home = config.env.set.get("CODEX_HOME").and_then(|value| {
            let trimmed = value.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(PathBuf::from(trimmed))
            }
        });
        let mut codex_home_guard = CodexHomeGuard::new(terminal_id, codex_home.clone());

        // Create PTY system
        let pty_system = native_pty_system();

        // Configure PTY size
        let size = PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        };

        // Open PTY pair (master + slave)
        let pair = pty_system
            .openpty(size)
            .map_err(|e| anyhow::anyhow!("Failed to open PTY: {e}"))?;

        // Build command
        // On Windows, use cmd.exe /c to run commands so that .cmd/.bat files are found
        #[cfg(windows)]
        let mut cmd = {
            let mut c = CommandBuilder::new("cmd.exe");
            c.arg("/c");
            c.arg(&config.command);
            for arg in &config.args {
                c.arg(arg);
            }
            c
        };
        #[cfg(not(windows))]
        let mut cmd = {
            let mut c = CommandBuilder::new(&config.command);
            for arg in &config.args {
                c.arg(arg);
            }
            c
        };
        cmd.cwd(&config.working_dir);

        // Set environment variables for proper terminal behavior
        cmd.env("TERM", "xterm-256color");
        cmd.env("COLORTERM", "truecolor");

        // UTF-8 encoding for Unix
        #[cfg(unix)]
        {
            cmd.env("LANG", "C.UTF-8");
            cmd.env("LC_ALL", "C.UTF-8");
        }

        // Remove inherited environment variables to prevent parent process pollution
        // This must be done BEFORE setting new values to ensure clean isolation
        for key in &config.env.unset {
            cmd.env_remove(key);
            tracing::debug!(
                terminal_id = %terminal_id,
                key = %key,
                "Removed inherited env var"
            );
        }

        // Inject custom environment variables for process-level isolation
        for (key, value) in &config.env.set {
            cmd.env(key, value);
            // Redact sensitive values in logs
            if SpawnEnv::is_sensitive_key(key) {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    key = %key,
                    "Injected env var [REDACTED]"
                );
            } else {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    key = %key,
                    value = %value,
                    "Injected env var"
                );
            }
        }

        // Capture CODEX_HOME for cleanup on process exit
        let codex_home = config.env.set.get("CODEX_HOME").and_then(|value| {
            let trimmed = value.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(PathBuf::from(trimmed))
            }
        });

        // Spawn child process on slave PTY
        let mut child = pair
            .slave
            .spawn_command(cmd)
            .map_err(|e| anyhow::anyhow!("Failed to spawn terminal process: {e}"))?;

        let pid = child.process_id().unwrap_or(0);
        let session_id = Uuid::new_v4().to_string();

        // Wait a short time and check if the process is still alive
        // This catches cases where the command fails immediately (e.g., not found, permission denied)
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        match child.try_wait() {
            Ok(Some(status)) => {
                return Err(anyhow::anyhow!(
                    "Terminal process exited immediately with status: {:?}. The CLI may not be installed correctly.",
                    status
                ));
            }
            Ok(None) => {
                // Process is still running, good
            }
            Err(e) => {
                return Err(anyhow::anyhow!(
                    "Failed to check terminal process status: {e}"
                ));
            }
        }

        // Initialize output fanout and background reader
        let output_fanout = Self::default_output_fanout();
        let reader_task = match pair.master.try_clone_reader() {
            Ok(reader) => Some(Self::spawn_output_reader_task(
                terminal_id,
                PtyReader(reader),
                Arc::clone(&output_fanout),
            )),
            Err(e) => {
                tracing::warn!(
                    terminal_id = %terminal_id,
                    error = %e,
                    "Failed to initialize background PTY reader for fanout"
                );
                None
            }
        };

        // Store tracked process
        let mut processes = self.processes.write().await;
        processes.insert(
            terminal_id.to_string(),
            TrackedProcess {
                session_id: session_id.clone(),
                child,
                master: Mutex::new(pair.master),
                shared_writer: None,
                codex_home,
                output_fanout,
                reader_task,
                logger_task: None,
                logger_shutdown_tx: None,
            },
        );

        // Disarm the guard - CODEX_HOME cleanup is now managed by TrackedProcess
        codex_home_guard.disarm();

        tracing::info!(
            terminal_id = %terminal_id,
            pid = pid,
            command = %config.command,
            args_count = config.args.len(),
            env_set_count = config.env.set.len(),
            env_unset_count = config.env.unset.len(),
            "PTY process spawned with config successfully"
        );

        Ok(ProcessHandle {
            pid,
            session_id,
            terminal_id: terminal_id.to_string(),
            reader: None,
            writer: None,
        })
    }

    /// Spawns a new terminal process with PTY
    ///
    /// Creates a new PTY and spawns the shell process attached to it.
    /// The process is tracked by its terminal ID and can be monitored or terminated later.
    ///
    /// # Arguments
    ///
    /// * `terminal_id` - Unique identifier for this terminal session
    /// * `shell` - The shell command to spawn (e.g., "powershell", "bash")
    /// * `working_dir` - Directory where the process will run
    /// * `cols` - Initial terminal width in columns
    /// * `rows` - Initial terminal height in rows
    ///
    /// # Returns
    ///
    /// Returns a `ProcessHandle` containing the PID and session ID.
    pub async fn spawn_pty(
        &self,
        terminal_id: &str,
        shell: &str,
        working_dir: &Path,
        cols: u16,
        rows: u16,
    ) -> anyhow::Result<ProcessHandle> {
        // Create PTY system
        let pty_system = native_pty_system();

        // Configure PTY size
        let size = PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        };

        // Open PTY pair (master + slave)
        let pair = pty_system
            .openpty(size)
            .map_err(|e| anyhow::anyhow!("Failed to open PTY: {e}"))?;

        // Build command
        // On Windows, use cmd.exe /c to run commands so that .cmd/.bat files are found
        #[cfg(windows)]
        let mut cmd = {
            let mut c = CommandBuilder::new("cmd.exe");
            c.arg("/c");
            c.arg(shell);
            c
        };
        #[cfg(not(windows))]
        let mut cmd = CommandBuilder::new(shell);
        cmd.cwd(working_dir);

        // Set environment variables for proper terminal behavior
        cmd.env("TERM", "xterm-256color");
        cmd.env("COLORTERM", "truecolor");

        // UTF-8 encoding for Unix
        #[cfg(unix)]
        {
            cmd.env("LANG", "C.UTF-8");
            cmd.env("LC_ALL", "C.UTF-8");
        }

        // Spawn child process on slave PTY
        let mut child = pair
            .slave
            .spawn_command(cmd)
            .map_err(|e| anyhow::anyhow!("Failed to spawn terminal process: {e}"))?;

        let pid = child.process_id().unwrap_or(0);
        let session_id = Uuid::new_v4().to_string();

        // Wait a short time and check if the process is still alive
        // This catches cases where the command fails immediately (e.g., not found, permission denied)
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        match child.try_wait() {
            Ok(Some(status)) => {
                return Err(anyhow::anyhow!(
                    "Terminal process exited immediately with status: {:?}. The CLI may not be installed correctly.",
                    status
                ));
            }
            Ok(None) => {
                // Process is still running, good
            }
            Err(e) => {
                return Err(anyhow::anyhow!(
                    "Failed to check terminal process status: {e}"
                ));
            }
        }

        // Initialize output fanout and background reader
        let output_fanout = Self::default_output_fanout();
        let reader_task = match pair.master.try_clone_reader() {
            Ok(reader) => Some(Self::spawn_output_reader_task(
                terminal_id,
                PtyReader(reader),
                Arc::clone(&output_fanout),
            )),
            Err(e) => {
                tracing::warn!(
                    terminal_id = %terminal_id,
                    error = %e,
                    "Failed to initialize background PTY reader for fanout"
                );
                None
            }
        };

        // Store tracked process
        let mut processes = self.processes.write().await;
        processes.insert(
            terminal_id.to_string(),
            TrackedProcess {
                session_id: session_id.clone(),
                child,
                master: Mutex::new(pair.master),
                shared_writer: None,
                codex_home: None, // Legacy spawn_pty doesn't support CODEX_HOME
                output_fanout,
                reader_task,
                logger_task: None,
                logger_shutdown_tx: None,
            },
        );

        tracing::info!(
            terminal_id = %terminal_id,
            pid = pid,
            shell = %shell,
            "PTY process spawned successfully"
        );

        Ok(ProcessHandle {
            pid,
            session_id,
            terminal_id: terminal_id.to_string(),
            reader: None,
            writer: None,
        })
    }

    /// Resize terminal PTY
    ///
    /// # Arguments
    ///
    /// * `terminal_id` - Terminal ID to resize
    /// * `cols` - New width in columns
    /// * `rows` - New height in rows
    pub async fn resize(&self, terminal_id: &str, cols: u16, rows: u16) -> anyhow::Result<()> {
        let processes = self.processes.read().await;

        if let Some(tracked) = processes.get(terminal_id) {
            let size = PtySize {
                rows,
                cols,
                pixel_width: 0,
                pixel_height: 0,
            };

            let master = tracked
                .master
                .lock()
                .map_err(|e| anyhow::anyhow!("Failed to lock PTY master: {e}"))?;

            master
                .resize(size)
                .map_err(|e| anyhow::anyhow!("Failed to resize PTY: {e}"))?;

            tracing::debug!(
                terminal_id = %terminal_id,
                cols = cols,
                rows = rows,
                "PTY resized"
            );

            Ok(())
        } else {
            Err(anyhow::anyhow!("Terminal not found: {terminal_id}"))
        }
    }

    /// Terminates a process by its PID
    ///
    /// Sends a termination signal to the process with the given PID.
    /// On Unix, sends SIGTERM. On Windows, uses taskkill /F.
    pub fn kill(&self, pid: u32) -> anyhow::Result<()> {
        // Safety check: PID 0 is invalid and could cause unintended behavior
        if pid == 0 {
            return Err(anyhow::anyhow!(
                "Invalid PID 0: cannot kill process with PID 0"
            ));
        }

        #[cfg(unix)]
        {
            use nix::{
                sys::signal::{self, Signal},
                unistd::Pid,
            };
            signal::kill(Pid::from_raw(pid as i32), Signal::SIGTERM)
                .map_err(|e| anyhow::anyhow!("Failed to kill process {pid}: {e}"))?;
        }

        #[cfg(windows)]
        {
            let output = std::process::Command::new("taskkill")
                .args(["/PID", &pid.to_string(), "/F"])
                .output()
                .map_err(|e| anyhow::anyhow!("Failed to execute taskkill: {e}"))?;

            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                return Err(anyhow::anyhow!("taskkill failed: {stderr}"));
            }
        }

        Ok(())
    }

    /// Kill terminal by terminal ID
    pub async fn kill_terminal(&self, terminal_id: &str) -> anyhow::Result<()> {
        {
            let mut processes = self.processes.write().await;
            let tracked = processes
                .get_mut(terminal_id)
                .ok_or_else(|| anyhow::anyhow!("Terminal not found: {terminal_id}"))?;

            match tracked.child.kill() {
                Ok(()) => {}
                Err(kill_error) => {
                    let exited_already = matches!(tracked.child.try_wait(), Ok(Some(_)));
                    if !exited_already {
                        return Err(anyhow::anyhow!(
                            "Failed to kill terminal {terminal_id}: {kill_error}"
                        ));
                    }
                    tracing::debug!(
                        terminal_id = %terminal_id,
                        "Child process already exited before kill"
                    );
                }
            }
        }

        let tracked = {
            let mut processes = self.processes.write().await;
            processes.remove(terminal_id)
        };

        if let Some(tracked) = tracked {
            self.finalize_terminated_process(terminal_id, tracked).await;
        } else {
            tracing::debug!(
                terminal_id = %terminal_id,
                "Terminal tracking already removed after kill"
            );
        }

        tracing::info!(terminal_id = %terminal_id, "Terminal killed");
        Ok(())
    }

    /// Check if a terminal process is running
    pub async fn is_running(&self, terminal_id: &str) -> bool {
        let processes = self.processes.read().await;
        processes.contains_key(terminal_id)
    }

    /// Lists all currently tracked terminal IDs
    pub async fn list_running(&self) -> Vec<String> {
        let processes = self.processes.read().await;
        processes.keys().cloned().collect()
    }

    /// Removes dead processes from tracking
    pub async fn cleanup(&self) {
        let cleanup_targets = {
            let mut processes = self.processes.write().await;

            let dead_ids: Vec<String> = processes
                .iter_mut()
                .filter_map(|(id, tracked)| match tracked.child.try_wait() {
                    Ok(Some(_)) => Some(id.clone()),
                    _ => None,
                })
                .collect();

            let mut targets = Vec::new();
            for id in dead_ids {
                if let Some(tracked) = processes.remove(&id) {
                    targets.push((id, tracked));
                }
            }

            targets
        };

        for (id, tracked) in cleanup_targets {
            self.finalize_terminated_process(&id, tracked).await;
            tracing::debug!(terminal_id = %id, "Removed dead process from tracking");
        }
    }

    /// Get process handle by terminal ID
    ///
    /// Returns a ProcessHandle containing the PTY reader/writer for the terminal process.
    /// This method supports multiple calls for WebSocket reconnection scenarios:
    /// - Reader is cloned on each call (portable-pty supports multiple readers)
    /// - Writer is shared via Arc<Mutex> (initialized on first call, then reused)
    pub async fn get_handle(&self, terminal_id: &str) -> Option<ProcessHandle> {
        let mut processes = self.processes.write().await;

        if let Some(tracked) = processes.get_mut(terminal_id) {
            let session_id = tracked.session_id.clone();

            // Initialize shared writer on first call, then reuse for reconnections
            if tracked.shared_writer.is_none() {
                let master = match tracked.master.lock() {
                    Ok(m) => m,
                    Err(e) => {
                        tracing::error!(
                            terminal_id = %terminal_id,
                            error = %e,
                            "Failed to lock PTY master"
                        );
                        return None;
                    }
                };

                match master.take_writer() {
                    Ok(w) => {
                        tracked.shared_writer = Some(Arc::new(Mutex::new(PtyWriter(w))));
                        tracing::debug!(
                            terminal_id = %terminal_id,
                            "Initialized shared PTY writer"
                        );
                    }
                    Err(e) => {
                        tracing::error!(
                            terminal_id = %terminal_id,
                            error = %e,
                            "Failed to take PTY writer"
                        );
                    }
                }
            }

            // Clone the Arc reference for the caller
            let writer = tracked.shared_writer.as_ref().map(Arc::clone);

            // Get PID from child
            let pid = tracked.child.process_id().unwrap_or(0);

            Some(ProcessHandle {
                pid,
                session_id,
                terminal_id: terminal_id.to_string(),
                // Reader is now owned by background fanout task (single-reader constraint)
                reader: None,
                writer,
            })
        } else {
            None
        }
    }

    /// Subscribe to terminal output stream with replay support.
    ///
    /// - `from_seq = None`: replay retained window from earliest.
    /// - `from_seq = Some(n)`: replay from `n + 1`.
    ///
    /// This enables late subscribers (like PromptWatcher) to receive output
    /// that was emitted before they subscribed, preventing "first-screen prompt loss".
    pub async fn subscribe_output(
        &self,
        terminal_id: &str,
        from_seq: Option<u64>,
    ) -> anyhow::Result<OutputSubscription> {
        let processes = self.processes.read().await;
        let tracked = processes
            .get(terminal_id)
            .ok_or_else(|| anyhow::anyhow!("Terminal not found: {terminal_id}"))?;
        Ok(tracked.output_fanout.subscribe(from_seq))
    }

    /// Get latest emitted output sequence for a terminal.
    ///
    /// Returns None if terminal doesn't exist, or 0 if no output has been emitted yet.
    pub async fn latest_output_seq(&self, terminal_id: &str) -> Option<u64> {
        let processes = self.processes.read().await;
        processes
            .get(terminal_id)
            .map(|tracked| tracked.output_fanout.latest_seq())
    }

    /// Attach a persistent logger to terminal output fanout.
    ///
    /// This wires PTY output to `terminal_log` table persistence.
    pub async fn attach_terminal_logger(
        &self,
        db: Arc<DBService>,
        terminal_id: &str,
        log_type: &str,
        flush_interval_secs: u64,
    ) -> anyhow::Result<()> {
        {
            let processes = self.processes.read().await;
            if !processes.contains_key(terminal_id) {
                return Err(anyhow::anyhow!("Terminal not found: {terminal_id}"));
            }
        }

        let mut subscription = self.subscribe_output(terminal_id, None).await?;
        let (shutdown_tx, mut shutdown_rx) = oneshot::channel::<()>();
        let logger = TerminalLogger::new(
            db,
            terminal_id.to_string(),
            log_type.to_string(),
            flush_interval_secs,
        );
        let terminal_id_owned = terminal_id.to_string();
        let log_type_owned = log_type.to_string();
        let processes = Arc::clone(&self.processes);

        let logger_for_shutdown = logger.clone();
        let logger_task = tokio::spawn(async move {
            loop {
                tokio::select! {
                    _ = &mut shutdown_rx => {
                        tracing::debug!(
                            terminal_id = %terminal_id_owned,
                            "Terminal logger received shutdown signal"
                        );
                        break;
                    }
                    recv_result = subscription.recv() => {
                        match recv_result {
                            Ok(chunk) => {
                                if !chunk.text.is_empty() {
                                    logger.append(&chunk.text).await;
                                }
                                if chunk.dropped_invalid_bytes > 0 {
                                    logger
                                        .append(&format!(
                                            "[{}] dropped {} invalid UTF-8 bytes at seq={}",
                                            log_type_owned, chunk.dropped_invalid_bytes, chunk.seq
                                        ))
                                        .await;
                                }
                            }
                            Err(tokio::sync::broadcast::error::RecvError::Lagged(skipped)) => {
                                let resume_from = subscription.last_seq();
                                tracing::warn!(
                                    terminal_id = %terminal_id_owned,
                                    skipped = %skipped,
                                    resume_from_seq = resume_from,
                                    "Terminal logger output subscription lagged; attempting replay recovery"
                                );

                                logger
                                    .append(&format!(
                                        "[{}] output stream lagged: skipped={} replay_from_seq={}",
                                        log_type_owned, skipped, resume_from
                                    ))
                                    .await;

                                let recovered_subscription = {
                                    let tracked = processes.read().await;
                                    tracked
                                        .get(&terminal_id_owned)
                                        .map(|process| process.output_fanout.subscribe(Some(resume_from)))
                                };

                                match recovered_subscription {
                                    Some(new_subscription) => {
                                        subscription = new_subscription;
                                        tracing::info!(
                                            terminal_id = %terminal_id_owned,
                                            resume_from_seq = resume_from,
                                            "Terminal logger subscription recovered after lag"
                                        );
                                    }
                                    None => {
                                        tracing::warn!(
                                            terminal_id = %terminal_id_owned,
                                            "Terminal logger lag recovery aborted: terminal not found"
                                        );
                                        break;
                                    }
                                }
                            }
                            Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                                tracing::debug!(
                                    terminal_id = %terminal_id_owned,
                                    "Terminal logger output subscription closed"
                                );
                                break;
                            }
                        }
                    }
                }
            }

            if let Err(e) = logger_for_shutdown.flush().await {
                tracing::warn!(
                    terminal_id = %terminal_id_owned,
                    error = %e,
                    "Terminal logger final flush failed"
                );
            }
        });

        let mut processes = self.processes.write().await;
        let tracked = match processes.get_mut(terminal_id) {
            Some(tracked) => tracked,
            None => {
                let _ = shutdown_tx.send(());
                logger_task.abort();
                return Err(anyhow::anyhow!("Terminal not found: {terminal_id}"));
            }
        };
        if let Some(existing_shutdown) = tracked.logger_shutdown_tx.take() {
            let _ = existing_shutdown.send(());
        }
        if let Some(existing_task) = tracked.logger_task.take() {
            existing_task.abort();
        }
        tracked.logger_shutdown_tx = Some(shutdown_tx);
        tracked.logger_task = Some(logger_task);
        tracing::debug!(terminal_id = %terminal_id, log_type = %log_type, "Attached terminal logger to output fanout");
        Ok(())
    }
}

impl Default for ProcessManager {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// Terminal Logger
// ============================================================================

/// Batch logger for terminal output
///
/// Batches log lines and flushes them every second to reduce I/O overhead.
pub const DEFAULT_MAX_BUFFER_SIZE: usize = 1000;

pub struct TerminalLogger {
    buffer: Arc<RwLock<Vec<String>>>,
    flush_lock: Arc<AsyncMutex<()>>,
    flush_interval_secs: u64,
    max_buffer_size: usize,
    db: Arc<DBService>,
    terminal_id: String,
    log_type: String,
}

impl Clone for TerminalLogger {
    fn clone(&self) -> Self {
        Self {
            buffer: Arc::clone(&self.buffer),
            flush_lock: Arc::clone(&self.flush_lock),
            flush_interval_secs: self.flush_interval_secs,
            max_buffer_size: self.max_buffer_size,
            db: Arc::clone(&self.db),
            terminal_id: self.terminal_id.clone(),
            log_type: self.log_type.clone(),
        }
    }
}

impl TerminalLogger {
    pub fn new(
        db: Arc<DBService>,
        terminal_id: impl Into<String>,
        log_type: impl Into<String>,
        flush_interval_secs: u64,
    ) -> Self {
        Self::with_max_buffer_size(
            db,
            terminal_id,
            log_type,
            flush_interval_secs,
            DEFAULT_MAX_BUFFER_SIZE,
        )
    }

    pub fn with_max_buffer_size(
        db: Arc<DBService>,
        terminal_id: impl Into<String>,
        log_type: impl Into<String>,
        flush_interval_secs: u64,
        max_buffer_size: usize,
    ) -> Self {
        Self {
            buffer: Arc::new(RwLock::new(Vec::new())),
            flush_lock: Arc::new(AsyncMutex::new(())),
            flush_interval_secs,
            max_buffer_size: max_buffer_size.max(1),
            db,
            terminal_id: terminal_id.into(),
            log_type: log_type.into(),
        }
        .start_flush_task()
    }

    async fn persist_entries(
        db: &DBService,
        terminal_id: &str,
        log_type: &str,
        entries: &[String],
    ) -> anyhow::Result<()> {
        if entries.is_empty() {
            return Ok(());
        }

        let mut tx = db.pool.begin().await?;
        for line in entries {
            sqlx::query(
                r#"
                INSERT INTO terminal_log (id, terminal_id, log_type, content, created_at)
                VALUES (?1, ?2, ?3, ?4, ?5)
                "#,
            )
            .bind(Uuid::new_v4().to_string())
            .bind(terminal_id)
            .bind(log_type)
            .bind(line)
            .bind(chrono::Utc::now())
            .execute(&mut *tx)
            .await?;
        }
        tx.commit().await?;
        Ok(())
    }

    async fn flush_buffer(
        buffer: &Arc<RwLock<Vec<String>>>,
        flush_lock: &Arc<AsyncMutex<()>>,
        db: &DBService,
        terminal_id: &str,
        log_type: &str,
    ) -> anyhow::Result<()> {
        let _flush_guard = flush_lock.lock().await;

        let entries = {
            let buffer = buffer.read().await;
            if buffer.is_empty() {
                return Ok(());
            }
            buffer.clone()
        };

        Self::persist_entries(db, terminal_id, log_type, &entries).await?;

        let mut buffer = buffer.write().await;
        let drained = entries.len().min(buffer.len());
        if drained > 0 {
            buffer.drain(..drained);
        }

        Ok(())
    }

    fn start_flush_task(self) -> Self {
        let buffer = Arc::clone(&self.buffer);
        let flush_lock = Arc::clone(&self.flush_lock);
        let interval_secs = self.flush_interval_secs;
        let db = Arc::clone(&self.db);
        let terminal_id = self.terminal_id.clone();
        let log_type = self.log_type.clone();

        tokio::spawn(async move {
            let mut interval =
                tokio::time::interval(tokio::time::Duration::from_secs(interval_secs));
            loop {
                interval.tick().await;
                if let Err(e) =
                    Self::flush_buffer(&buffer, &flush_lock, &db, &terminal_id, &log_type).await
                {
                    tracing::error!(
                        terminal_id = %terminal_id,
                        log_type = %log_type,
                        error = %e,
                        "Failed to persist terminal logs in flush task"
                    );
                }
            }
        });

        self
    }

    pub async fn append(&self, line: &str) {
        let should_flush = {
            let mut buffer = self.buffer.write().await;
            buffer.push(line.to_string());
            buffer.len() >= self.max_buffer_size
        };

        if !should_flush {
            return;
        }

        if let Err(e) = Self::flush_buffer(
            &self.buffer,
            &self.flush_lock,
            &self.db,
            &self.terminal_id,
            &self.log_type,
        )
        .await
        {
            tracing::error!(
                terminal_id = %self.terminal_id,
                log_type = %self.log_type,
                error = %e,
                "Failed to persist terminal logs in append-triggered flush"
            );
        }
    }

    pub async fn flush(&self) -> anyhow::Result<()> {
        Self::flush_buffer(
            &self.buffer,
            &self.flush_lock,
            &self.db,
            &self.terminal_id,
            &self.log_type,
        )
        .await
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_logger_test_db_with_terminal(terminal_id: &str) -> Arc<DBService> {
        use std::str::FromStr;

        use sqlx::sqlite::{SqliteConnectOptions, SqlitePoolOptions};

        let options = SqliteConnectOptions::from_str(":memory:")
            .unwrap()
            .pragma("foreign_keys", "0");
        let pool = SqlitePoolOptions::new()
            .connect_with(options)
            .await
            .unwrap();

        let migrator = sqlx::migrate!("../db/migrations");
        migrator.run(&pool).await.unwrap();

        let db = Arc::new(DBService { pool });

        let project_id = Uuid::new_v4();
        sqlx::query("INSERT INTO projects (id, name, created_at, updated_at) VALUES (?, ?, ?, ?)")
            .bind(project_id)
            .bind("test-project")
            .bind(chrono::Utc::now())
            .bind(chrono::Utc::now())
            .execute(&db.pool)
            .await
            .unwrap();

        let workflow_id = Uuid::new_v4().to_string();
        sqlx::query(
            "INSERT INTO workflow (id, project_id, name, status, merge_terminal_cli_id, merge_terminal_model_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&workflow_id)
        .bind(project_id)
        .bind("test-workflow")
        .bind("created")
        .bind("cli-claude-code")
        .bind("model-claude-sonnet")
        .bind(chrono::Utc::now())
        .bind(chrono::Utc::now())
        .execute(&db.pool)
        .await
        .unwrap();

        let workflow_task_id = Uuid::new_v4().to_string();
        sqlx::query(
            "INSERT INTO workflow_task (id, workflow_id, name, branch, order_index, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&workflow_task_id)
        .bind(&workflow_id)
        .bind("task-1")
        .bind("main")
        .bind(0)
        .bind("pending")
        .bind(chrono::Utc::now())
        .bind(chrono::Utc::now())
        .execute(&db.pool)
        .await
        .unwrap();

        sqlx::query(
            "INSERT INTO terminal (id, workflow_task_id, cli_type_id, model_config_id, order_index, status, auto_confirm, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(terminal_id)
        .bind(&workflow_task_id)
        .bind("cli-claude-code")
        .bind("model-claude-sonnet")
        .bind(0)
        .bind("waiting")
        .bind(true)
        .bind(chrono::Utc::now())
        .bind(chrono::Utc::now())
        .execute(&db.pool)
        .await
        .unwrap();

        db
    }

    #[tokio::test]
    async fn test_process_manager_new() {
        let manager = ProcessManager::new();
        let running = manager.list_running().await;
        assert_eq!(running.len(), 0, "New manager should have no processes");
    }

    #[tokio::test]
    async fn test_process_manager_default() {
        let manager = ProcessManager::default();
        let running = manager.list_running().await;
        assert_eq!(running.len(), 0);
    }

    #[tokio::test]
    async fn test_spawn_pty_creates_process() {
        let manager = ProcessManager::new();
        let temp_dir = tempfile::tempdir().unwrap();

        // Use platform-specific shell
        #[cfg(windows)]
        let shell = "cmd.exe";
        #[cfg(unix)]
        let shell = "sh";

        let result = manager
            .spawn_pty("test-terminal", shell, temp_dir.path(), 80, 24)
            .await;

        assert!(result.is_ok(), "Spawn should succeed: {:?}", result.err());
        let handle = result.unwrap();
        assert_eq!(handle.terminal_id, "test-terminal");
        assert!(!handle.session_id.is_empty());

        // Cleanup
        let _ = manager.kill_terminal("test-terminal").await;
    }

    #[tokio::test]
    async fn test_get_handle_returns_pty_handles() {
        let manager = ProcessManager::new();
        let temp_dir = tempfile::tempdir().unwrap();

        #[cfg(windows)]
        let shell = "cmd.exe";
        #[cfg(unix)]
        let shell = "sh";

        let _ = manager
            .spawn_pty("test-terminal", shell, temp_dir.path(), 80, 24)
            .await;

        // In new architecture, reader is owned by background fanout task
        // get_handle() returns reader: None, writer: Some
        let handle1 = manager.get_handle("test-terminal").await;
        assert!(handle1.is_some());
        let handle1 = handle1.unwrap();
        assert!(
            handle1.reader.is_none(),
            "Reader should be None (owned by fanout task)"
        );
        assert!(handle1.writer.is_some());

        // Second call should also return handle with shared writer
        let handle2 = manager.get_handle("test-terminal").await;
        assert!(handle2.is_some());
        let handle2 = handle2.unwrap();
        assert!(
            handle2.reader.is_none(),
            "Reader should be None (owned by fanout task)"
        );
        assert!(handle2.writer.is_some());

        assert_eq!(
            handle1.session_id, handle2.session_id,
            "Session ID should remain stable across reconnections"
        );

        // Verify that writers are the same Arc (shared)
        let writer1 = handle1.writer.as_ref().unwrap();
        let writer2 = handle2.writer.as_ref().unwrap();
        assert!(
            Arc::ptr_eq(writer1, writer2),
            "Writers should be shared via Arc"
        );

        // Verify subscribe_output works (new API for reading output)
        let subscription = manager.subscribe_output("test-terminal", None).await;
        assert!(
            subscription.is_ok(),
            "Should be able to subscribe to output"
        );

        // Cleanup
        let _ = manager.kill_terminal("test-terminal").await;
    }

    #[tokio::test]
    async fn test_terminal_logger_flush_manual_flush_persists() {
        let terminal_id = Uuid::new_v4().to_string();
        let db = setup_logger_test_db_with_terminal(&terminal_id).await;

        let logger = TerminalLogger::with_max_buffer_size(
            Arc::clone(&db),
            terminal_id.clone(),
            "stdout",
            60,
            100,
        );

        logger.append("tail-line").await;
        logger.flush().await.unwrap();

        let rows: Vec<String> = sqlx::query_scalar(
            "SELECT content FROM terminal_log WHERE terminal_id = ? ORDER BY created_at ASC",
        )
        .bind(&terminal_id)
        .fetch_all(&db.pool)
        .await
        .unwrap();

        assert!(rows.iter().any(|row| row == "tail-line"));
    }

    #[tokio::test]
    async fn test_terminal_logger_flush_when_buffer_reaches_limit() {
        let terminal_id = Uuid::new_v4().to_string();
        let db = setup_logger_test_db_with_terminal(&terminal_id).await;

        let logger = TerminalLogger::with_max_buffer_size(
            Arc::clone(&db),
            terminal_id.clone(),
            "stdout",
            60,
            1,
        );

        logger.append("limit-triggered-line").await;
        logger.flush().await.unwrap();

        let rows: Vec<String> = sqlx::query_scalar(
            "SELECT content FROM terminal_log WHERE terminal_id = ? ORDER BY created_at ASC",
        )
        .bind(&terminal_id)
        .fetch_all(&db.pool)
        .await
        .unwrap();

        assert!(rows.iter().any(|row| row == "limit-triggered-line"));
    }

    #[tokio::test]
    async fn test_kill_terminal_nonexistent_returns_error() {
        let manager = ProcessManager::new();
        let result = manager.kill_terminal("missing-terminal").await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_resize_pty() {
        let manager = ProcessManager::new();
        let temp_dir = tempfile::tempdir().unwrap();

        #[cfg(windows)]
        let shell = "cmd.exe";
        #[cfg(unix)]
        let shell = "sh";

        let _ = manager
            .spawn_pty("test-terminal", shell, temp_dir.path(), 80, 24)
            .await;

        // Resize should succeed
        let result = manager.resize("test-terminal", 120, 40).await;
        assert!(result.is_ok());

        // Cleanup
        let _ = manager.kill_terminal("test-terminal").await;
    }

    #[tokio::test]
    async fn test_get_handle_for_nonexistent_terminal() {
        let manager = ProcessManager::new();
        let handle = manager.get_handle("non-existent").await;
        assert!(handle.is_none());
    }
}
