//! Message bus -> PTY input bridge.
//!
//! Subscribes to PTY session topics and forwards terminal messages to stdin.
//! This enables the Orchestrator to send commands and confirmations to CLI tools.

use std::{collections::HashMap, sync::Arc, time::Duration};

use tokio::{
    sync::{RwLock, mpsc},
    task::JoinHandle,
    time::MissedTickBehavior,
};

use super::process::ProcessManager;
use crate::services::orchestrator::message_bus::{BusMessage, SharedMessageBus};

// ============================================================================
// Constants
// ============================================================================

/// Channel capacity for PTY writer queue.
const BRIDGE_CHANNEL_CAPACITY: usize = 100;

/// Health check interval for terminal liveness (seconds).
const BRIDGE_HEALTH_INTERVAL_SECS: u64 = 5;

// ============================================================================
// Bridge Handle
// ============================================================================

/// Internal handle for tracking active bridge tasks.
struct BridgeHandle {
    terminal_id: String,
    task_handle: JoinHandle<()>,
}

// ============================================================================
// Terminal Bridge
// ============================================================================

/// Bridges MessageBus terminal topics to PTY stdin.
///
/// This component enables bidirectional communication between the Orchestrator
/// and CLI tools running in PTY terminals. When the Orchestrator publishes a
/// `TerminalMessage` to a PTY session topic, this bridge forwards it to the
/// terminal's stdin.
///
/// # Architecture
///
/// ```text
/// Orchestrator -> MessageBus -> TerminalBridge -> PTY stdin
/// ```
///
/// # Usage
///
/// ```ignore
/// let bridge = TerminalBridge::new(message_bus, process_manager);
/// bridge.register("terminal-123", "session-456").await?;
/// ```
#[derive(Clone)]
pub struct TerminalBridge {
    message_bus: SharedMessageBus,
    process_manager: Arc<ProcessManager>,
    active_sessions: Arc<RwLock<HashMap<String, BridgeHandle>>>,
}

impl TerminalBridge {
    /// Creates a new TerminalBridge instance.
    ///
    /// # Arguments
    ///
    /// * `message_bus` - Shared message bus for subscribing to topics
    /// * `process_manager` - Process manager for accessing PTY handles
    pub fn new(message_bus: SharedMessageBus, process_manager: Arc<ProcessManager>) -> Self {
        Self {
            message_bus,
            process_manager,
            active_sessions: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Registers a bridge task for a PTY session topic.
    ///
    /// This method subscribes to the PTY session topic and spawns a background
    /// task that forwards incoming `TerminalMessage` events to the PTY stdin.
    ///
    /// # Arguments
    ///
    /// * `terminal_id` - Terminal identifier for PTY handle lookup
    /// * `pty_session_id` - PTY session ID used as the message bus topic
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if registration succeeds, or an error if the session ID
    /// is empty or registration fails.
    pub async fn register(&self, terminal_id: &str, pty_session_id: &str) -> anyhow::Result<()> {
        let session_id = pty_session_id.trim();
        if session_id.is_empty() {
            return Err(anyhow::anyhow!("pty_session_id is empty"));
        }
        if terminal_id.trim().is_empty() {
            return Err(anyhow::anyhow!("terminal_id is empty"));
        }

        // Check if already registered
        {
            let active = self.active_sessions.read().await;
            if active.contains_key(session_id) {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %session_id,
                    "Terminal bridge already registered"
                );
                return Ok(());
            }
        }

        // Subscribe to both the new terminal-input topic and legacy PTY-session topic
        let terminal_input_topic = format!("terminal.input.{}", terminal_id);
        let mut rx_terminal_input = self.message_bus.subscribe(&terminal_input_topic).await;
        let mut rx_legacy = self.message_bus.subscribe(session_id).await;

        let process_manager = Arc::clone(&self.process_manager);
        let session_id_owned = session_id.to_string();
        let terminal_input_topic_owned = terminal_input_topic.clone();
        let terminal_id_owned = terminal_id.to_string();
        let terminal_id_for_task = terminal_id.to_string();
        let active_sessions = Arc::clone(&self.active_sessions);

        // Spawn bridge task
        let task_handle = tokio::spawn(async move {
            let result = Self::run_bridge(
                process_manager,
                terminal_id_for_task.clone(),
                session_id_owned.clone(),
                terminal_input_topic_owned.clone(),
                &mut rx_terminal_input,
                &mut rx_legacy,
            )
            .await;

            // Remove from active sessions on exit
            {
                let mut active = active_sessions.write().await;
                active.remove(&session_id_owned);
            }

            match result {
                Ok(()) => {
                    tracing::debug!(
                        terminal_id = %terminal_id_for_task,
                        pty_session_id = %session_id_owned,
                        "Terminal bridge stopped gracefully"
                    );
                }
                Err(e) => {
                    tracing::warn!(
                        terminal_id = %terminal_id_for_task,
                        pty_session_id = %session_id_owned,
                        error = %e,
                        "Terminal bridge stopped with error"
                    );
                }
            }
        });

        // Register the bridge handle (with race condition check)
        {
            let mut active = self.active_sessions.write().await;
            if active.contains_key(session_id) {
                // Another task registered while we were setting up
                task_handle.abort();
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %session_id,
                    "Terminal bridge registration race: existing session kept"
                );
                return Ok(());
            }

            active.insert(
                session_id.to_string(),
                BridgeHandle {
                    terminal_id: terminal_id_owned,
                    task_handle,
                },
            );
        }

        tracing::info!(
            terminal_id = %terminal_id,
            pty_session_id = %session_id,
            terminal_input_topic = %terminal_input_topic,
            "Terminal bridge registered"
        );

        Ok(())
    }

    /// Unregisters a bridge task for a PTY session.
    ///
    /// # Arguments
    ///
    /// * `pty_session_id` - PTY session ID to unregister
    pub async fn unregister(&self, pty_session_id: &str) {
        let mut active = self.active_sessions.write().await;
        if let Some(handle) = active.remove(pty_session_id) {
            handle.task_handle.abort();
            tracing::info!(
                terminal_id = %handle.terminal_id,
                pty_session_id = %pty_session_id,
                "Terminal bridge unregistered"
            );
        }
    }

    /// Returns the number of active bridge sessions.
    pub async fn active_count(&self) -> usize {
        self.active_sessions.read().await.len()
    }

    /// Returns whether a PTY session currently has an active bridge task.
    pub async fn is_registered(&self, pty_session_id: &str) -> bool {
        self.active_sessions
            .read()
            .await
            .contains_key(pty_session_id)
    }

    /// Helper method to forward a bus message to PTY stdin.
    async fn forward_bus_message(
        tx: &mpsc::Sender<Vec<u8>>,
        terminal_id: &str,
        pty_session_id: &str,
        msg: Option<BusMessage>,
    ) -> anyhow::Result<bool> {
        match msg {
            Some(BusMessage::TerminalMessage { message }) => {
                let payload = Self::normalize_message(&message);
                if payload.is_empty() {
                    return Ok(false);
                }
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %pty_session_id,
                    message_len = payload.len(),
                    "Forwarding legacy TerminalMessage to PTY stdin"
                );
                tx.send(payload.into_bytes())
                    .await
                    .map_err(|_| anyhow::anyhow!("PTY writer channel closed"))?;
                Ok(false)
            }
            Some(BusMessage::TerminalInput {
                terminal_id: message_terminal_id,
                session_id: message_session_id,
                input,
                ..
            }) => {
                // Strict routing check: accept only matching terminal or session
                if message_terminal_id != terminal_id && message_session_id != pty_session_id {
                    return Ok(false);
                }

                let payload = Self::normalize_message(&input);
                if payload.is_empty() {
                    return Ok(false);
                }
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %pty_session_id,
                    message_len = payload.len(),
                    "Forwarding TerminalInput to PTY stdin"
                );
                tx.send(payload.into_bytes())
                    .await
                    .map_err(|_| anyhow::anyhow!("PTY writer channel closed"))?;
                Ok(false)
            }
            Some(BusMessage::Shutdown) => {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %pty_session_id,
                    "Terminal bridge received shutdown"
                );
                Ok(true)
            }
            Some(_) => Ok(false),
            None => {
                tracing::debug!(
                    terminal_id = %terminal_id,
                    pty_session_id = %pty_session_id,
                    "Terminal bridge channel closed"
                );
                Ok(true)
            }
        }
    }

    /// Main bridge loop that forwards messages to PTY stdin.
    async fn run_bridge(
        process_manager: Arc<ProcessManager>,
        terminal_id: String,
        pty_session_id: String,
        terminal_input_topic: String,
        rx_terminal_input: &mut mpsc::Receiver<BusMessage>,
        rx_legacy: &mut mpsc::Receiver<BusMessage>,
    ) -> anyhow::Result<()> {
        // Get PTY handle
        let handle = process_manager
            .get_handle(&terminal_id)
            .await
            .ok_or_else(|| anyhow::anyhow!("Terminal not running: {}", terminal_id))?;

        let writer = handle.writer.ok_or_else(|| {
            anyhow::anyhow!("PTY writer unavailable for terminal {}", terminal_id)
        })?;

        // Create channel for writer task
        let (tx, mut writer_rx) = mpsc::channel::<Vec<u8>>(BRIDGE_CHANNEL_CAPACITY);
        let terminal_id_writer = terminal_id.clone();

        // Spawn blocking writer task
        let mut writer_task = tokio::task::spawn_blocking(move || -> anyhow::Result<()> {
            while let Some(data) = writer_rx.blocking_recv() {
                let mut writer_guard = match writer.lock() {
                    Ok(guard) => guard,
                    Err(poisoned) => {
                        tracing::warn!(
                            terminal_id = %terminal_id_writer,
                            "PTY writer lock poisoned; recovering"
                        );
                        poisoned.into_inner()
                    }
                };

                if let Err(e) = writer_guard.write_all(&data) {
                    return Err(anyhow::anyhow!("PTY write error: {e}"));
                }
                if let Err(e) = writer_guard.flush() {
                    return Err(anyhow::anyhow!("PTY flush error: {e}"));
                }
            }
            Ok(())
        });

        let mut writer_finished = false;
        let mut health_interval =
            tokio::time::interval(Duration::from_secs(BRIDGE_HEALTH_INTERVAL_SECS));
        health_interval.set_missed_tick_behavior(MissedTickBehavior::Skip);

        tracing::debug!(
            terminal_id = %terminal_id,
            pty_session_id = %pty_session_id,
            terminal_input_topic = %terminal_input_topic,
            "Terminal bridge loop started"
        );

        loop {
            tokio::select! {
                msg = rx_terminal_input.recv() => {
                    if Self::forward_bus_message(&tx, &terminal_id, &pty_session_id, msg).await? {
                        break;
                    }
                }
                msg = rx_legacy.recv() => {
                    if Self::forward_bus_message(&tx, &terminal_id, &pty_session_id, msg).await? {
                        break;
                    }
                }
                _ = health_interval.tick() => {
                    // Cleanup dead processes
                    process_manager.cleanup().await;

                    // Check if terminal is still running
                    if !process_manager.is_running(&terminal_id).await {
                        tracing::info!(
                            terminal_id = %terminal_id,
                            pty_session_id = %pty_session_id,
                            "Terminal process no longer running; stopping bridge"
                        );
                        break;
                    }
                }
                result = &mut writer_task => {
                    writer_finished = true;
                    match result {
                        Ok(Ok(())) => {}
                        Ok(Err(e)) => return Err(e),
                        Err(e) => return Err(anyhow::anyhow!("Writer task join error: {e}")),
                    }
                    break;
                }
            }
        }

        // Clean shutdown: close sender and wait for writer task
        drop(tx);

        if !writer_finished {
            match writer_task.await {
                Ok(Ok(())) => {}
                Ok(Err(e)) => return Err(e),
                Err(e) => return Err(anyhow::anyhow!("Writer task join error: {e}")),
            }
        }

        Ok(())
    }

    /// Normalizes a message by ensuring it ends with an Enter key payload.
    ///
    /// PTY-based TUIs are generally Enter-key driven (`\r`) rather than
    /// line-feed-driven (`\n`/`\r\n`).
    ///
    /// # Arguments
    ///
    /// * `message` - The message to normalize
    ///
    /// # Returns
    ///
    /// The normalized message with appropriate line ending.
    fn normalize_message(message: &str) -> String {
        let mut payload = message.to_string();

        if payload.is_empty() {
            return "\r".to_string();
        }

        if payload.ends_with("\r\n") {
            payload.truncate(payload.len().saturating_sub(2));
            payload.push('\r');
            return payload;
        }

        if payload.ends_with('\n') {
            payload.pop();
            payload.push('\r');
            return payload;
        }

        if payload.ends_with('\r') {
            return payload;
        }

        payload.push('\r');
        payload
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_message_adds_newline() {
        let result = TerminalBridge::normalize_message("hello");
        assert!(result.ends_with('\r'), "Should end with carriage return");
    }

    #[test]
    fn test_normalize_message_preserves_existing_newline() {
        let result = TerminalBridge::normalize_message("hello\n");
        assert_eq!(result, "hello\r", "LF should normalize to carriage return");
    }

    #[test]
    fn test_normalize_message_converts_existing_crlf() {
        let result = TerminalBridge::normalize_message("hello\r\n");
        assert_eq!(
            result, "hello\r",
            "CRLF should normalize to a single carriage return"
        );
    }

    #[test]
    fn test_normalize_message_empty_string() {
        let result = TerminalBridge::normalize_message("");
        assert_eq!(result, "\r", "Empty string should normalize to Enter key");
    }
}
