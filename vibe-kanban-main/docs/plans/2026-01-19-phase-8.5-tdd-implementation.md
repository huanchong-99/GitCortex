# Phase 8.5: Code Quality Fix - TDD Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Fix 13 critical code quality issues identified by Senior Code Auditor (C/68 rating) to bring codebase to production-ready standard.

**Architecture:**
- **Test-First Development:** Every feature starts with failing test
- **Active Record Pattern:** Database operations via model methods (no DAO layer)
- **Message Bus:** Event-driven architecture using tokio channels
- **Encryption:** AES-256-GCM for API keys with environment variable key

**Tech Stack:**
- Rust 1.75+ with sqlx 0.8.6 (compile-time query checking)
- tokio async runtime
- aes-gcm 0.10 for encryption
- secrecy 0.10 for secret handling
- wiremock for HTTP testing
- Existing test infrastructure in `crates/services/src/services/orchestrator/tests.rs`

---

## P0 TASKS - CRITICAL FIXES

### Task 1: Implement SendToTerminal Instruction (8.5.1.1)

**Files:**
- Modify: `crates/services/src/services/orchestrator/agent.rs:211-280`
- Test: `crates/services/src/services/orchestrator/tests.rs`

**Step 1: Write failing test for SendToTerminal**

```rust
// Add to crates/services/src/services/orchestrator/tests.rs at line ~690

#[tokio::test]
async fn test_execute_instruction_send_to_terminal() {
    // Setup
    let (db, workflow, _terminal) = setup_test_workflow().await;
    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: None,
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Create PTY session reference
    let pty_session_id = Uuid::new_v4().to_string();

    // Update terminal with PTY session
    sqlx::query(
        "UPDATE terminal SET pty_session_id = ? WHERE terminal_id = ?"
    )
    .bind(&pty_session_id)
    .bind(&_terminal.terminal_id)
    .execute(&db.pool)
    .await
    .unwrap();

    // Subscribe to terminal topic to verify message sent
    let mut terminal_rx = message_bus.subscribe(&pty_session_id).await.unwrap();

    // Execute instruction
    let instruction = OrchestratorInstruction::SendToTerminal {
        terminal_id: _terminal.terminal_id.clone(),
        message: "echo test".to_string(),
    };

    // Run in task to allow async message propagation
    tokio::spawn(async move {
        agent.execute_instruction(&workflow.workflow_id, instruction).await
    });

    // Verify message received on terminal topic
    let timeout = tokio::time::timeout(
        tokio::time::Duration::from_millis(500),
        terminal_rx.recv()
    ).await;

    assert!(timeout.is_ok(), "Should receive message within timeout");

    let msg = timeout.unwrap().unwrap();
    match msg {
        BusMessage::TerminalMessage { message } => {
            assert_eq!(message, "echo test");
        }
        _ => panic!("Expected TerminalMessage, got {:?}", msg),
    }
}
```

**Step 2: Run test to verify it fails**

```bash
cd .worktrees/phase-8.5-code-quality-fix/vibe-kanban-main
cargo test -p services test_execute_instruction_send_to_terminal -- --nocapture
```

Expected: `FAIL` - "TODO: implement SendToTerminal" or panic

**Step 3: Implement SendToTerminal in agent.rs**

Replace the TODO at line 211 with:

```rust
OrchestratorInstruction::SendToTerminal { terminal_id, message } => {
    tracing::info!("Sending to terminal {}: {}", terminal_id, message);

    // 1. Get terminal from database
    let terminal = Terminal::find_by_id(&self.db.pool, &terminal_id).await
        .map_err(|e| anyhow::anyhow!("Failed to get terminal: {}", e))?
        .ok_or_else(|| anyhow::anyhow!("Terminal {} not found", terminal_id))?;

    // 2. Get PTY session ID
    let pty_session_id = terminal.pty_session_id
        .ok_or_else(|| anyhow::anyhow!("Terminal {} has no PTY session", terminal_id))?;

    // 3. Send message via message bus
    self.message_bus.publish(
        &pty_session_id,
        BusMessage::TerminalMessage { message }
    ).await
    .map_err(|e| anyhow::anyhow!("Failed to send message: {}", e))?;

    tracing::debug!("Message sent to terminal {}", terminal_id);
}
```

**Step 4: Run test to verify it passes**

```bash
cargo test -p services test_execute_instruction_send_to_terminal -- --nocapture
```

Expected: `PASS`

**Step 5: Commit**

```bash
git add crates/services/src/services/orchestrator/agent.rs crates/services/src/services/orchestrator/tests.rs
git commit -m "feat(orchestrator): implement SendToTerminal instruction with test"
```

---

### Task 2: Implement CompleteWorkflow Instruction (8.5.1.2)

**Files:**
- Modify: `crates/services/src/services/orchestrator/agent.rs:280-340`
- Test: `crates/services/src/services/orchestrator/tests.rs`

**Step 1: Write failing test for CompleteWorkflow**

```rust
#[tokio::test]
async fn test_execute_instruction_complete_workflow_success() {
    let (db, workflow, _terminal) = setup_test_workflow().await;

    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: None,
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Subscribe to workflow topic
    let mut workflow_rx = message_bus.subscribe(
        &format!("workflow:{}", workflow.workflow_id)
    ).await.unwrap();

    // Execute instruction
    let instruction = OrchestratorInstruction::CompleteWorkflow {
        success: true,
        reason: "All tasks completed successfully".to_string(),
    };

    tokio::spawn(async move {
        agent.execute_instruction(&workflow.workflow_id, instruction).await
    });

    // Verify workflow status updated
    let updated_workflow = Workflow::find_by_id(
        &db.pool,
        &workflow.workflow_id
    ).await.unwrap().unwrap();

    assert_eq!(updated_workflow.status, "completed");

    // Verify completion event published
    let timeout = tokio::time::timeout(
        tokio::time::Duration::from_millis(500),
        workflow_rx.recv()
    ).await;

    assert!(timeout.is_ok());

    let msg = timeout.unwrap().unwrap();
    match msg {
        BusMessage::WorkflowEvent(WorkflowEvent::Completed { workflow_id, success, reason }) => {
            assert_eq!(workflow_id, workflow.workflow_id);
            assert!(success);
            assert_eq!(reason, "All tasks completed successfully");
        }
        _ => panic!("Expected WorkflowEvent::Completed"),
    }

    // Verify agent state is Idle
    assert_eq!(
        agent.state.read().await.run_state,
        OrchestratorRunState::Idle
    );
}

#[tokio::test]
async fn test_execute_instruction_complete_workflow_failure() {
    let (db, workflow, _terminal) = setup_test_workflow().await;

    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: None,
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Execute instruction with failure
    let instruction = OrchestratorInstruction::CompleteWorkflow {
        success: false,
        reason: "Critical error in task execution".to_string(),
    };

    agent.execute_instruction(&workflow.workflow_id, instruction).await.unwrap();

    // Verify workflow status is failed
    let updated_workflow = Workflow::find_by_id(
        &db.pool,
        &workflow.workflow_id
    ).await.unwrap().unwrap();

    assert_eq!(updated_workflow.status, "failed");
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test -p services test_execute_instruction_complete_workflow -- --nocapture
```

Expected: `FAIL` - TODO or panic

**Step 3: Implement CompleteWorkflow in agent.rs**

```rust
OrchestratorInstruction::CompleteWorkflow { success, reason } => {
    tracing::info!(
        "Completing workflow: success={}, reason={}",
        success, reason
    );

    // 1. Update workflow status
    let new_status = if success {
        "completed"
    } else {
        "failed"
    };

    Workflow::update_status(
        &self.db.pool,
        &self.config.workflow_id,
        new_status
    ).await
    .map_err(|e| anyhow::anyhow!("Failed to update workflow status: {}", e))?;

    // 2. Publish completion event
    let event = WorkflowEvent::Completed {
        workflow_id: self.config.workflow_id.clone(),
        success,
        reason: reason.clone(),
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await
    .map_err(|e| anyhow::anyhow!("Failed to publish completion event: {}", e))?;

    // 3. Transition to Idle
    self.state.write().await.run_state = OrchestratorRunState::Idle;

    tracing::info!("Workflow {} completed with status: {}", self.config.workflow_id, new_status);
}
```

**Step 4: Run tests to verify they pass**

```bash
cargo test -p services test_execute_instruction_complete_workflow -- --nocapture
```

Expected: `PASS` x2

**Step 5: Commit**

```bash
git add crates/services/src/services/orchestrator/agent.rs crates/services/src/services/orchestrator/tests.rs
git commit -m "feat(orchestrator): implement CompleteWorkflow instruction with tests"
```

---

### Task 3: Implement FailWorkflow Instruction (8.5.1.3)

**Files:**
- Modify: `crates/services/src/services/orchestrator/agent.rs:340-410`
- Test: `crates/services/src/services/orchestrator/tests.rs`

**Step 1: Add ErrorSeverity enum to types.rs if not exists**

```rust
// Add to crates/services/src/services/orchestrator/types.rs

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ErrorSeverity {
    Minor,
    Major,
    Critical,
}
```

**Step 2: Write failing test for FailWorkflow**

```rust
#[tokio::test]
async fn test_execute_instruction_fail_workflow() {
    let (db, workflow, terminal) = setup_test_workflow().await;

    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: Some(terminal.terminal_id.clone()),
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Subscribe to terminal topic
    let mut terminal_rx = message_bus.subscribe(&terminal.terminal_id).await.unwrap();

    // Execute instruction with critical error
    let instruction = OrchestratorInstruction::FailWorkflow {
        error: "Database connection lost".to_string(),
        severity: ErrorSeverity::Critical,
    };

    tokio::spawn(async move {
        agent.execute_instruction(&workflow.workflow_id, instruction).await
    });

    // Verify error message sent to error terminal
    let timeout = tokio::time::timeout(
        tokio::time::Duration::from_millis(500),
        terminal_rx.recv()
    ).await;

    assert!(timeout.is_ok());

    let msg = timeout.unwrap().unwrap();
    match msg {
        BusMessage::TerminalMessage { message } => {
            assert!(message.contains("ERROR"));
            assert!(message.contains("Database connection lost"));
        }
        _ => panic!("Expected TerminalMessage with error"),
    }

    // Verify workflow status
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let updated_workflow = Workflow::find_by_id(
        &db.pool,
        &workflow.workflow_id
    ).await.unwrap().unwrap();

    assert_eq!(updated_workflow.status, "failed");

    // Verify agent state is Idle
    assert_eq!(
        agent.state.read().await.run_state,
        OrchestratorRunState::Idle
    );
}
```

**Step 3: Run test to verify it fails**

```bash
cargo test -p services test_execute_instruction_fail_workflow -- --nocapture
```

Expected: `FAIL`

**Step 4: Implement FailWorkflow in agent.rs**

```rust
OrchestratorInstruction::FailWorkflow { error, severity } => {
    tracing::error!("Workflow failed: {} (severity: {:?})", error, severity);

    // 1. Send error to error terminal for Major/Critical
    if let Some(error_terminal_id) = &self.config.error_terminal_id {
        if matches!(severity, ErrorSeverity::Major | ErrorSeverity::Critical) {
            let error_message = format!(
                "[ERROR] Workflow failed: {}\n\nSeverity: {:?}\nPlease investigate and fix.",
                error, severity
            );

            if let Err(e) = self.message_bus.publish(
                error_terminal_id,
                BusMessage::TerminalMessage { message: error_message }
            ).await {
                tracing::warn!("Failed to send error to terminal: {}", e);
            }
        }
    }

    // 2. Update workflow status to failed
    Workflow::update_status(
        &self.db.pool,
        &self.config.workflow_id,
        "failed"
    ).await
    .map_err(|e| anyhow::anyhow!("Failed to update workflow status: {}", e))?;

    // 3. Publish failure event
    let event = WorkflowEvent::Failed {
        workflow_id: self.config.workflow_id.clone(),
        error,
        severity,
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await
    .map_err(|e| anyhow::anyhow!("Failed to publish failure event: {}", e))?;

    // 4. Transition to Idle
    self.state.write().await.run_state = OrchestratorRunState::Idle;
}
```

**Step 5: Run test to verify it passes**

```bash
cargo test -p services test_execute_instruction_fail_workflow -- --nocapture
```

Expected: `PASS`

**Step 6: Commit**

```bash
git add crates/services/src/services/orchestrator/agent.rs crates/services/src/services/orchestrator/types.rs crates/services/src/services/orchestrator/tests.rs
git commit -m "feat(orchestrator): implement FailWorkflow instruction with error severity"
```

---

### Task 4: Add AES-GCM Encryption Dependency (8.5.2.1)

**Files:**
- Modify: `crates/db/Cargo.toml`

**Step 1: Add dependencies to Cargo.toml**

```toml
# Add to crates/db/Cargo.toml [dependencies] section

aes-gcm = "0.10"
base64 = "0.21"
```

**Step 2: Run cargo check**

```bash
cargo check -p db
```

Expected: Success (dependencies fetched)

**Step 3: Commit**

```bash
git add crates/db/Cargo.toml
git commit -m "feat(db): add AES-GCM encryption dependencies for API key security"
```

---

### Task 5: Implement API Key Encryption in Workflow Model (8.5.2.2)

**Files:**
- Modify: `crates/db/src/models/workflow.rs:1-150`
- Test: `crates/db/src/models/workflow.rs` (add tests module)

**Step 1: Write failing test for encryption/decryption**

```rust
// Add to crates/db/src/models/workflow.rs at the end

#[cfg(test)]
mod encryption_tests {
    use super::*;

    #[test]
    fn test_api_key_encryption_decryption() {
        // Setup encryption key
        std::env::set_var("GITCORTEX_ENCRYPTION_KEY", "12345678901234567890123456789012");

        let mut workflow = Workflow {
            workflow_id: "test-workflow".to_string(),
            cli_type_id: "test-cli".to_string(),
            orchestrator_api_key_encrypted: None,
            status: "pending".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            order_index: 0,
        };

        // Test encryption
        let original_key = "sk-test-key-12345";
        workflow.set_api_key(original_key).unwrap();

        assert!(workflow.orchestrator_api_key_encrypted.is_some());
        assert_ne!(
            workflow.orchestrator_api_key_encrypted.unwrap(),
            original_key,
            "Encrypted key should not match original"
        );

        // Test decryption
        let decrypted_key = workflow.get_api_key().unwrap().unwrap();
        assert_eq!(decrypted_key, original_key);
    }

    #[test]
    fn test_api_key_encryption_missing_env_key() {
        // Clear environment variable
        std::env::remove_var("GITCORTEX_ENCRYPTION_KEY");

        let mut workflow = Workflow {
            workflow_id: "test-workflow".to_string(),
            cli_type_id: "test-cli".to_string(),
            orchestrator_api_key_encrypted: None,
            status: "pending".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            order_index: 0,
        };

        // Should fail without encryption key
        let result = workflow.set_api_key("sk-test");
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("GITCORTEX_ENCRYPTION_KEY"));
    }

    #[test]
    fn test_api_key_encryption_invalid_key_length() {
        // Set invalid key (too short)
        std::env::set_var("GITCORTEX_ENCRYPTION_KEY", "short");

        let mut workflow = Workflow {
            workflow_id: "test-workflow".to_string(),
            cli_type_id: "test-cli".to_string(),
            orchestrator_api_key_encrypted: None,
            status: "pending".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            order_index: 0,
        };

        let result = workflow.set_api_key("sk-test");
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("32 bytes"));
    }

    #[test]
    fn test_api_key_none_when_not_set() {
        std::env::set_var("GITCORTEX_ENCRYPTION_KEY", "12345678901234567890123456789012");

        let workflow = Workflow {
            workflow_id: "test-workflow".to_string(),
            cli_type_id: "test-cli".to_string(),
            orchestrator_api_key_encrypted: None,
            status: "pending".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            order_index: 0,
        };

        let key = workflow.get_api_key().unwrap();
        assert!(key.is_none());
    }

    #[test]
    fn test_api_key_serialization_skips_encrypted() {
        std::env::set_var("GITCORTEX_ENCRYPTION_KEY", "12345678901234567890123456789012");

        let mut workflow = Workflow {
            workflow_id: "test-workflow".to_string(),
            cli_type_id: "test-cli".to_string(),
            orchestrator_api_key_encrypted: None,
            status: "pending".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            order_index: 0,
        };

        workflow.set_api_key("sk-test").unwrap();

        // Serialize to JSON
        let json = serde_json::to_string(&workflow).unwrap();

        // Encrypted field should not be in JSON (due to #[serde(skip_serializing)])
        assert!(!json.contains("orchestratorApiKeyEncrypted"));
        assert!(!json.contains("sk-test"));
    }
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test -p db encryption_tests -- --nocapture
```

Expected: `FAIL` - Methods don't exist yet

**Step 3: Implement encryption methods in workflow.rs**

Add to top of file:

```rust
use aes_gcm::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Aes256Gcm, Nonce, Key
};
use base64::{Engine as _, engine::general_purpose};
```

Modify Workflow struct:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Workflow {
    pub workflow_id: String,
    pub cli_type_id: String,

    // Replace orchestrator_api_key with encrypted version
    #[serde(skip_serializing)]
    pub orchestrator_api_key_encrypted: Option<String>,

    pub status: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub order_index: i32,
}
```

Add implementation block:

```rust
impl Workflow {
    const ENCRYPTION_KEY_ENV: &str = "GITCORTEX_ENCRYPTION_KEY";

    /// Get encryption key from environment variable
    fn get_encryption_key() -> anyhow::Result<[u8; 32]> {
        std::env::var(Self::ENCRYPTION_KEY_ENV)
            .map_err(|_| anyhow::anyhow!(
                "Encryption key not found. Please set {} environment variable with a 32-byte value.",
                Self::ENCRYPTION_KEY_ENV
            ))?
            .as_bytes()
            .try_into()
            .map_err(|_| anyhow::anyhow!(
                "Invalid encryption key length. Must be exactly 32 bytes (64 hex chars or 32 ASCII chars)."
            ))
    }

    /// Set API key with encryption
    pub fn set_api_key(&mut self, plaintext: &str) -> anyhow::Result<()> {
        let key = Self::get_encryption_key()?;
        let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key));
        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);

        let ciphertext = cipher.encrypt(&nonce, plaintext.as_bytes())
            .map_err(|e| anyhow::anyhow!("Encryption failed: {}", e))?;

        // Combine nonce + ciphertext
        let mut combined = nonce.to_vec();
        combined.extend_from_slice(&ciphertext);

        // Base64 encode
        self.orchestrator_api_key_encrypted = Some(
            general_purpose::STANDARD.encode(&combined)
        );

        tracing::debug!("API key encrypted for workflow {}", self.workflow_id);
        Ok(())
    }

    /// Get API key with decryption
    pub fn get_api_key(&self) -> anyhow::Result<Option<String>> {
        match &self.orchestrator_api_key_encrypted {
            None => Ok(None),
            Some(encoded) => {
                let key = Self::get_encryption_key()?;
                let combined = general_purpose::STANDARD.decode(encoded)
                    .map_err(|e| anyhow::anyhow!("Base64 decode failed: {}", e))?;

                if combined.len() < 12 {
                    return Err(anyhow::anyhow!("Invalid encrypted data length"));
                }

                let (nonce_bytes, ciphertext) = combined.split_at(12);
                let nonce = Nonce::from_slice(nonce_bytes);
                let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key));

                let plaintext_bytes = cipher.decrypt(nonce, ciphertext)
                    .map_err(|e| anyhow::anyhow!("Decryption failed: {}", e))?;

                Ok(Some(String::from_utf8(plaintext_bytes)
                    .map_err(|e| anyhow::anyhow!("Invalid UTF-8 in decrypted data: {}", e))?))
            }
        }
    }
}
```

**Step 4: Run tests to verify they pass**

```bash
cargo test -p db encryption_tests -- --nocapture
```

Expected: `PASS` x5

**Step 5: Commit**

```bash
git add crates/db/src/models/workflow.rs
git commit -m "feat(db): implement AES-256-GCM encryption for API keys with comprehensive tests"
```

---

### Task 6: Create Database Migration for Encrypted API Keys (8.5.2.3)

**Files:**
- Create: `crates/db/migrations/{timestamp}_encrypt_api_keys.sql`

**Step 1: Create migration file**

```bash
# Generate timestamp
TIMESTAMP=$(date +%Y%m%d%H%M%S)
MIGRATION_FILE="crates/db/migrations/${TIMESTAMP}_encrypt_api_keys.sql"
```

**Step 2: Write migration SQL**

```sql
-- Migration: Add encrypted API key column
-- This adds a new column for encrypted API keys
-- Data migration will be handled in application code

-- Add new encrypted column
ALTER TABLE workflow ADD COLUMN orchestrator_api_key_encrypted TEXT;

-- Old column will be dropped after data migration is verified
-- ALTER TABLE workflow DROP COLUMN orchestrator_api_key;
```

**Step 3: Commit**

```bash
git add crates/db/migrations/${TIMESTAMP}_encrypt_api_keys.sql
git commit -m "feat(db): add migration for encrypted API key storage"
```

---

### Task 7: Create Commit Parser Module (8.5.3.1)

**Files:**
- Create: `crates/services/src/services/git_watcher/commit_parser.rs`
- Test: `crates/services/src/services/git_watcher/commit_parser_tests.rs`

**Step 1: Write failing tests for commit parser**

```rust
// Create: crates/services/src/services/git_watcher/commit_parser_tests.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_commit_metadata_valid() {
        let commit_message = r#"
Implement user authentication

---METADATA---
{"workflow_id":"wf-123","task_id":"task-456","terminal_id":"term-789","status":"completed","reviewed_terminal":null,"issues":null,"files_changed":[{"path":"src/auth.rs","change_type":"modified"}]}
"#;

        let metadata = parse_commit_metadata(commit_message).unwrap();

        assert_eq!(metadata.workflow_id, "wf-123");
        assert_eq!(metadata.task_id, "task-456");
        assert_eq!(metadata.terminal_id, "term-789");
        assert_eq!(metadata.status, "completed");
    }

    #[test]
    fn test_parse_commit_metadata_review_pass() {
        let commit_message = r#"
Review approved

---METADATA---
{"workflow_id":"wf-123","task_id":"task-456","terminal_id":"reviewer-term","status":"review_pass","reviewed_terminal":"term-789","issues":null,"files_changed":[]}
"#;

        let metadata = parse_commit_metadata(commit_message).unwrap();

        assert_eq!(metadata.status, "review_pass");
        assert_eq!(metadata.reviewed_terminal, Some("term-789".to_string()));
    }

    #[test]
    fn test_parse_commit_metadata_review_reject() {
        let commit_message = r#"
Review rejected

---METADATA---
{"workflow_id":"wf-123","task_id":"task-456","terminal_id":"reviewer-term","status":"review_reject","reviewed_terminal":"term-789","issues":[{"line":42,"severity":"error","message":"Missing error handling"}],"files_changed":[]}
"#;

        let metadata = parse_commit_metadata(commit_message).unwrap();

        assert_eq!(metadata.status, "review_reject");
        assert_eq!(metadata.issues.len(), 1);
        assert_eq!(metadata.issues[0].line, 42);
    }

    #[test]
    fn test_parse_commit_metadata_no_metadata() {
        let commit_message = "Regular commit without metadata";

        let result = parse_commit_metadata(commit_message);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("METADATA"));
    }

    #[test]
    fn test_parse_commit_metadata_invalid_json() {
        let commit_message = r#"
Commit with bad metadata

---METADATA---
{invalid json}
"#;

        let result = parse_commit_metadata(commit_message);
        assert!(result.is_err());
    }
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test -p services commit_parser -- --nocapture
```

Expected: `FAIL` - Module doesn't exist

**Step 3: Implement commit parser module**

```rust
// Create: crates/services/src/services/git_watcher/commit_parser.rs

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};

const METADATA_SEPARATOR: &str = "---METADATA---";

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FileChange {
    pub path: String,
    #[serde(rename = "changeType")]
    pub change_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Issue {
    pub line: u32,
    pub severity: String,
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CommitMetadata {
    pub workflow_id: String,
    pub task_id: String,
    pub terminal_id: String,
    pub status: String,
    pub reviewed_terminal: Option<String>,
    pub issues: Option<Vec<Issue>>,
    pub files_changed: Vec<FileChange>,
}

/// Parse commit message to extract metadata
///
/// Expected format:
/// ```text
/// Commit message title
///
/// Optional description
///
/// ---METADATA---
/// {"workflow_id":"wf-123",...}
/// ```
pub fn parse_commit_metadata(commit_message: &str) -> Result<CommitMetadata> {
    // Find separator
    let separator_pos = commit_message
        .find(METADATA_SEPARATOR)
        .ok_or_else(|| anyhow!("Commit metadata separator '{}' not found", METADATA_SEPARATOR))?;

    // Extract JSON after separator
    let json_str = commit_message[separator_pos + METADATA_SEPARATOR.len()..]
        .trim();

    // Parse JSON
    let metadata: CommitMetadata = serde_json::from_str(json_str)
        .map_err(|e| anyhow!("Failed to parse commit metadata JSON: {}", e))?;

    // Validate required fields
    if metadata.workflow_id.is_empty() {
        return Err(anyhow!("workflow_id cannot be empty"));
    }

    tracing::debug!(
        "Parsed commit metadata: workflow={}, task={}, terminal={}, status={}",
        metadata.workflow_id,
        metadata.task_id,
        metadata.terminal_id,
        metadata.status
    );

    Ok(metadata)
}

#[cfg(test)]
mod tests {
    use super::*;

    // Include tests from Step 1 here...
}
```

**Step 4: Add module to git_watcher/mod.rs**

```rust
// Add to crates/services/src/services/git_watcher/mod.rs

pub mod commit_parser;

pub use commit_parser::{CommitMetadata, FileChange, Issue, parse_commit_metadata};
```

**Step 5: Run tests to verify they pass**

```bash
cargo test -p services commit_parser -- --nocapture
```

Expected: `PASS` x5

**Step 6: Commit**

```bash
git add crates/services/src/services/git_watcher/
git commit -m "feat(git_watcher): implement commit metadata parser with comprehensive tests"
```

---

### Task 8: Implement handle_git_event Core Logic (8.5.3.2)

**Files:**
- Modify: `crates/services/src/services/orchestrator/agent.rs:156-200`
- Test: `crates/services/src/services/orchestrator/tests.rs`

**Step 1: Write failing test for handle_git_event**

```rust
#[tokio::test]
async fn test_handle_git_event_terminal_completed() {
    let (db, workflow, terminal) = setup_test_workflow().await;

    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: None,
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Subscribe to workflow topic
    let mut workflow_rx = message_bus.subscribe(
        &format!("workflow:{}", workflow.workflow_id)
    ).await.unwrap();

    // Create valid commit message
    let commit_message = format!(
        r#"Terminal completed

---METADATA---
{{"workflow_id":"{}","task_id":"task-1","terminal_id":"{}","status":"completed","reviewed_terminal":null,"issues":null,"files_changed":[{{"path":"src/main.rs","changeType":"modified"}}]}}"#,
        workflow.workflow_id, terminal.terminal_id
    );

    // Handle git event
    agent.handle_git_event(
        &workflow.workflow_id,
        "abc123",
        "main",
        commit_message.as_str()
    ).await.unwrap();

    // Verify terminal status updated
    let updated_terminal = Terminal::find_by_id(
        &db.pool,
        &terminal.terminal_id
    ).await.unwrap().unwrap();

    assert_eq!(updated_terminal.status, "completed");

    // Verify event published
    let timeout = tokio::time::timeout(
        tokio::time::Duration::from_millis(500),
        workflow_rx.recv()
    ).await;

    assert!(timeout.is_ok());
}

#[tokio::test]
async fn test_handle_git_event_workflow_mismatch() {
    let (db, workflow, _terminal) = setup_test_workflow().await;

    let config = OrchestratorConfig {
        workflow_id: workflow.workflow_id.clone(),
        api_type: "openai".to_string(),
        base_url: "https://api.openai.com/v1".to_string(),
        api_key: "sk-test".to_string(),
        model: "gpt-4".to_string(),
        max_retries: 3,
        timeout_secs: 120,
        system_prompt: String::new(),
        error_terminal_id: None,
    };

    let message_bus = Arc::new(MessageBus::new());
    let mock_llm = Box::new(MockLLMClient {
        should_fail: false,
        response_content: String::new(),
    });

    let agent = OrchestratorAgent::with_llm_client(
        config.clone(),
        message_bus.clone(),
        mock_llm,
        db.clone(),
    );

    // Create commit with different workflow ID
    let commit_message = r#"
Terminal completed

---METADATA---
{"workflow_id":"different-workflow","task_id":"task-1","terminal_id":"term-1","status":"completed","reviewed_terminal":null,"issues":null,"files_changed":[]}
"#;

    // Should succeed but do nothing (workflow mismatch)
    let result = agent.handle_git_event(
        &workflow.workflow_id,
        "abc123",
        "main",
        commit_message
    ).await;

    assert!(result.is_ok());
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test -p services test_handle_git_event -- --nocapture
```

Expected: `FAIL` - Empty implementation

**Step 3: Implement handle_git_event in agent.rs**

Replace empty implementation at line 156:

```rust
async fn handle_git_event(
    &self,
    workflow_id: &str,
    commit_hash: &str,
    branch: &str,
    message: &str,
) -> anyhow::Result<()> {
    tracing::info!(
        "Git event: {} on branch {} - {}",
        commit_hash, branch, message
    );

    // 1. Parse commit metadata
    let metadata = crate::services::git_watcher::parse_commit_metadata(message)?;

    // 2. Validate workflow_id matches
    if metadata.workflow_id != workflow_id {
        tracing::warn!(
            "Workflow ID mismatch: expected {}, got {}",
            workflow_id, metadata.workflow_id
        );
        return Ok(());
    }

    // 3. Route to handler based on status
    match metadata.status.as_str() {
        "completed" => {
            self.handle_terminal_completed(
                &metadata.terminal_id,
                &metadata.task_id,
                commit_hash,
                message,
                metadata.files_changed,
            ).await?;
        }
        "review_pass" => {
            self.handle_review_pass(
                &metadata.terminal_id,
                &metadata.task_id,
                &metadata.reviewed_terminal.ok_or_else(|| anyhow!("reviewed_terminal required for review_pass"))?,
            ).await?;
        }
        "review_reject" => {
            self.handle_review_reject(
                &metadata.terminal_id,
                &metadata.task_id,
                &metadata.reviewed_terminal.ok_or_else(|| anyhow!("reviewed_terminal required for review_reject"))?,
                &metadata.issues.ok_or_else(|| anyhow!("issues required for review_reject"))?,
            ).await?;
        }
        "failed" => {
            self.handle_terminal_failed(
                &metadata.terminal_id,
                &metadata.task_id,
                message,
            ).await?;
        }
        _ => {
            tracing::warn!("Unknown status in commit: {}", metadata.status);
        }
    }

    Ok(())
}
```

**Step 4: Implement helper methods**

Add to agent.rs:

```rust
async fn handle_terminal_completed(
    &self,
    terminal_id: &str,
    task_id: &str,
    commit_hash: &str,
    commit_message: &str,
    files_changed: Vec<crate::db::models::FileChange>,
) -> anyhow::Result<()> {
    tracing::info!(
        "Terminal {} completed task {} (commit: {})",
        terminal_id, task_id, commit_hash
    );

    // 1. Update terminal status
    Terminal::update_status(
        &self.db.pool,
        terminal_id,
        "completed"
    ).await?;

    // 2. Publish completion event
    let event = WorkflowEvent::TerminalCompleted {
        workflow_id: self.config.workflow_id.clone(),
        task_id: task_id.to_string(),
        terminal_id: terminal_id.to_string(),
        commit_hash: commit_hash.to_string(),
        commit_message: commit_message.to_string(),
        files_changed: files_changed.into_iter().map(|f| super::FileChange {
            path: f.path,
            change_type: f.change_type,
        }).collect(),
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await?;

    // 3. Awaken main agent
    self.awaken().await?;

    Ok(())
}

async fn handle_review_pass(
    &self,
    reviewer_terminal_id: &str,
    task_id: &str,
    reviewed_terminal_id: &str,
) -> anyhow::Result<()> {
    tracing::info!(
        "Terminal {} approved work from {}",
        reviewer_terminal_id, reviewed_terminal_id
    );

    // 1. Update reviewed terminal status
    Terminal::update_status(
        &self.db.pool,
        reviewed_terminal_id,
        "review_passed"
    ).await?;

    // 2. Publish review passed event
    let event = WorkflowEvent::ReviewPassed {
        workflow_id: self.config.workflow_id.clone(),
        task_id: task_id.to_string(),
        reviewer_terminal_id: reviewer_terminal_id.to_string(),
        reviewed_terminal_id: reviewed_terminal_id.to_string(),
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await?;

    // 3. Awaken main agent
    self.awaken().await?;

    Ok(())
}

async fn handle_review_reject(
    &self,
    reviewer_terminal_id: &str,
    task_id: &str,
    reviewed_terminal_id: &str,
    issues: &[crate::db::models::Issue],
) -> anyhow::Result<()> {
    tracing::warn!(
        "Terminal {} rejected work from {}: {} issues found",
        reviewer_terminal_id, reviewed_terminal_id, issues.len()
    );

    // 1. Update reviewed terminal status
    Terminal::update_status(
        &self.db.pool,
        reviewed_terminal_id,
        "review_rejected"
    ).await?;

    // 2. Publish review rejected event
    let event = WorkflowEvent::ReviewRejected {
        workflow_id: self.config.workflow_id.clone(),
        task_id: task_id.to_string(),
        reviewer_terminal_id: reviewer_terminal_id.to_string(),
        reviewed_terminal_id: reviewed_terminal_id.to_string(),
        issues: issues.to_vec(),
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await?;

    // 3. Awaken main agent
    self.awaken().await?;

    Ok(())
}

async fn handle_terminal_failed(
    &self,
    terminal_id: &str,
    task_id: &str,
    error_message: &str,
) -> anyhow::Result<()> {
    tracing::error!(
        "Terminal {} failed task {}: {}",
        terminal_id, task_id, error_message
    );

    // 1. Update terminal status
    Terminal::update_status(
        &self.db.pool,
        terminal_id,
        "failed"
    ).await?;

    // 2. Publish failure event
    let event = WorkflowEvent::TerminalFailed {
        workflow_id: self.config.workflow_id.clone(),
        task_id: task_id.to_string(),
        terminal_id: terminal_id.to_string(),
        error: error_message.to_string(),
    };

    self.message_bus.publish(
        &format!("workflow:{}", self.config.workflow_id),
        BusMessage::WorkflowEvent(event)
    ).await?;

    // 3. Awaken main agent
    self.awaken().await?;

    Ok(())
}
```

**Step 5: Run tests to verify they pass**

```bash
cargo test -p services test_handle_git_event -- --nocapture
```

Expected: `PASS` x2

**Step 6: Commit**

```bash
git add crates/services/src/services/orchestrator/agent.rs crates/services/src/services/orchestrator/tests.rs
git commit -m "feat(orchestrator): implement handle_git_event with status routing"
```

---

## P1 TASKS - CODE CLEANUP

### Task 9: Remove Unused Imports (8.5.4)

**Files:**
- Modify: Multiple files with unused imports

**Step 1: Run clippy to find all unused imports**

```bash
cargo clippy -p services 2>&1 | grep "unused"
```

**Step 2: Remove unused imports**

Based on baseline check, remove these imports:

```rust
// crates/services/src/services/orchestrator/agent.rs:11
- use message_bus::{BusMessage, MessageBus, SharedMessageBus};
+ use message_bus::{BusMessage, SharedMessageBus};

// crates/services/src/services/orchestrator/types.rs:3
- use std::collections::HashMap;

// crates/server/src/routes/cli_types.rs:6
- use Json, Router;
+ use Router;

// crates/server/src/routes/cli_types.rs:12
- use utils::response::ApiResponse;
```

**Step 3: Verify no warnings**

```bash
cargo clippy -p services
```

Expected: No unused import warnings

**Step 4: Commit**

```bash
git add crates/services/src/services/orchestrator/agent.rs crates/services/src/services/orchestrator/types.rs crates/server/src/routes/cli_types.rs
git commit -m "refactor: remove unused imports"
```

---

### Task 10: Verify db Field Usage (8.5.5)

**Files:**
- Already fixed in Task 1 (execute_instruction uses db field)

**Step 1: Verify no dead_code warnings**

```bash
cargo clippy -p services 2>&1 | grep "dead_code"
```

Expected: No warnings (db field is now used in execute_instruction)

**Step 2: No commit needed** (Fixed in Task 1)

---

### Task 11: Add Serde camelCase Configuration (8.5.6)

**Files:**
- Modify: All model files in `crates/db/src/models/`

**Step 1: Find all models without camelCase**

```bash
grep -r "derive.*Serialize.*Deserialize" crates/db/src/models/ | grep -v "rename_all"
```

**Step 2: Add camelCase to all models**

For each struct:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // Add this line
pub struct Workflow {
    // ...
}
```

Models to update:
- `crates/db/src/models/workflow.rs`
- `crates/db/src/models/terminal.rs`
- `crates/db/src/models/cli_type.rs`
- `crates/db/src/models/mod.rs`

**Step 3: Verify TypeScript types match**

Check `frontend/src/types/` for camelCase consistency

**Step 4: Commit**

```bash
git add crates/db/src/models/
git commit -m "refactor(db): add serde camelCase configuration for consistent API responses"
```

---

### Task 12: Implement Retry Mechanism for LLM (8.5.7)

**Files:**
- Modify: `crates/services/src/services/orchestrator/llm.rs`
- Test: `crates/services/src/services/orchestrator/tests.rs`

**Step 1: Write failing test for retry logic**

```rust
#[tokio::test]
async fn test_llm_retry_with_backoff() {
    use wiremock::{MockServer, Mock, ResponseTemplate};
    use wiremock::matchers::{method, path};

    let mock_server = MockServer::start().await;

    // First two attempts fail, third succeeds
    let mut call_count = 0;
    Mock::given(method("POST"))
        .and(path("/chat/completions"))
        .respond_with(move |req: &reqwest::Request| {
            call_count += 1;
            if call_count < 3 {
                ResponseTemplate::new(500).set_body_json(serde_json::json!({
                    "error": "Internal server error"
                }))
            } else {
                ResponseTemplate::new(200).set_body_json(serde_json::json!({
                    "choices": [{
                        "message": {
                            "content": "Success after retries"
                        }
                    }],
                    "usage": {
                        "prompt_tokens": 10,
                        "completion_tokens": 20
                    }
                }))
            }
        })
        .mount(&mock_server)
        .await;

    let client = OpenAICompatibleClient::new(
        mock_server.uri(),
        "sk-test".to_string(),
        "gpt-4".to_string()
    );

    let messages = vec![LLMMessage {
        role: "user".to_string(),
        content: "Test".to_string(),
    }];

    let result = client.chat(messages).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap().content, "Success after retries");
    assert_eq!(call_count, 3);
}
```

**Step 2: Run test to verify it fails**

```bash
cargo test -p services test_llm_retry -- --nocapture
```

Expected: `FAIL` - No retry logic

**Step 3: Implement retry with backoff in llm.rs**

```rust
use tokio::time::{sleep, Duration};
use std::future::Future;

/// Retry with exponential backoff
pub async fn retry_with_backoff<T, E, F, Fut>(
    max_retries: u32,
    mut operation: F,
) -> Result<T, E>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T, E>>,
{
    let mut last_error = None;

    for attempt in 0..max_retries {
        match operation().await {
            Ok(result) => {
                if attempt > 0 {
                    tracing::info!("Operation succeeded on attempt {}", attempt + 1);
                }
                return Ok(result);
            }
            Err(e) if attempt < max_retries - 1 => {
                tracing::warn!(
                    "Attempt {} failed, retrying in {}ms: {}",
                    attempt + 1,
                    1000 * (attempt + 1),
                    e
                );
                last_error = Some(e);
                sleep(Duration::from_millis(1000 * (attempt + 1) as u64)).await;
            }
            Err(e) => {
                tracing::error!("All {} attempts failed", max_retries);
                return Err(e);
            }
        }
    }

    Err(last_error.unwrap())
}

impl OpenAICompatibleClient {
    pub async fn chat(&self, messages: Vec<LLMMessage>) -> anyhow::Result<LLMResponse> {
        retry_with_backoff(3, || {
            self.chat_once(messages.clone())
        }).await
    }

    async fn chat_once(&self, messages: Vec<LLMMessage>) -> anyhow::Result<LLMResponse> {
        // Existing implementation (rename from chat to chat_once)
        // ...
    }
}
```

**Step 4: Run test to verify it passes**

```bash
cargo test -p services test_llm_retry -- --nocapture
```

Expected: `PASS`

**Step 5: Commit**

```bash
git add crates/services/src/services/orchestrator/llm.rs
git commit -m "feat(llm): add retry mechanism with exponential backoff"
```

---

## P2 TASKS - REFACTORING

### Task 13: Extract Magic Numbers to Config (8.5.8)

**Files:**
- Modify: `crates/services/src/services/orchestrator/config.rs`
- Modify: `crates/services/src/services/orchestrator/state.rs`

**Step 1: Add config fields**

```rust
// crates/services/src/services/orchestrator/config.rs

#[derive(Debug, Clone)]
pub struct OrchestratorConfig {
    pub api_type: String,
    pub base_url: String,
    pub api_key: String,
    pub model: String,
    pub max_conversation_history: usize,
    pub llm_timeout_secs: u64,
    pub max_retries: u32,
    pub retry_delay_ms: u64,
    pub system_prompt: String,
    pub error_terminal_id: Option<String>,
}

impl Default for OrchestratorConfig {
    fn default() -> Self {
        Self {
            api_type: String::new(),
            base_url: String::new(),
            api_key: String::new(),
            model: String::new(),
            max_conversation_history: 50,
            llm_timeout_secs: 120,
            max_retries: 3,
            retry_delay_ms: 1000,
            system_prompt: String::new(),
            error_terminal_id: None,
        }
    }
}
```

**Step 2: Update state.rs to use config**

```rust
// crates/services/src/services/orchestrator/state.rs

impl OrchestratorState {
    pub fn add_message(
        &mut self,
        max_history: usize,  // Pass in from config
        message: LLMMessage
    ) {
        self.conversation_history.push(message);

        // Prune if exceeds max
        if self.conversation_history.len() > max_history {
            let excess = self.conversation_history.len() - max_history;
            for _ in 0..excess {
                self.conversation_history.remove(0);
            }
        }
    }
}
```

**Step 3: Commit**

```bash
git add crates/services/src/services/orchestrator/config.rs crates/services/src/services/orchestrator/state.rs
git commit -m "refactor(orchestrator): extract magic numbers to configuration"
```

---

### Task 14: Extract String Constants (8.5.9)

**Files:**
- Create: `crates/services/src/services/orchestrator/constants.rs`

**Step 1: Create constants module**

```rust
// Create: crates/services/src/services/orchestrator/constants.rs

/// Topic prefixes for message bus
pub const WORKFLOW_TOPIC_PREFIX: &str = "workflow:";
pub const TERMINAL_TOPIC_PREFIX: &str = "terminal:";
pub const GIT_EVENT_TOPIC_PREFIX: &str = "git_event:";

/// Commit metadata format
pub const GIT_COMMIT_METADATA_SEPARATOR: &str = "---METADATA---";

/// Environment variable names
pub const ENCRYPTION_KEY_ENV: &str = "GITCORTEX_ENCRYPTION_KEY";

/// Default configuration values
pub const DEFAULT_MAX_CONVERSATION_HISTORY: usize = 50;
pub const DEFAULT_LLM_TIMEOUT_SECS: u64 = 120;
pub const DEFAULT_MAX_RETRIES: u32 = 3;
pub const DEFAULT_RETRY_DELAY_MS: u64 = 1000;

/// Terminal status values
pub const TERMINAL_STATUS_PENDING: &str = "pending";
pub const TERMINAL_STATUS_RUNNING: &str = "running";
pub const TERMINAL_STATUS_COMPLETED: &str = "completed";
pub const TERMINAL_STATUS_FAILED: &str = "failed";
pub const TERMINAL_STATUS_REVIEW_PASSED: &str = "review_passed";
pub const TERMINAL_STATUS_REVIEW_REJECTED: &str = "review_rejected";

/// Workflow status values
pub const WORKFLOW_STATUS_PENDING: &str = "pending";
pub const WORKFLOW_STATUS_RUNNING: &str = "running";
pub const WORKFLOW_STATUS_COMPLETED: &str = "completed";
pub const WORKFLOW_STATUS_FAILED: &str = "failed";
```

**Step 2: Replace hardcoded strings**

Search and replace:
- `"workflow:"` -> `constants::WORKFLOW_TOPIC_PREFIX`
- `"---METADATA---"` -> `constants::GIT_COMMIT_METADATA_SEPARATOR`
- etc.

**Step 3: Commit**

```bash
git add crates/services/src/services/orchestrator/
git commit -m "refactor(orchestrator): extract hardcoded strings to constants"
```

---

### Task 15: Implement State Transition Validation (8.5.10)

**Files:**
- Modify: `crates/services/src/services/orchestrator/state.rs`

**Step 1: Add transition validation method**

```rust
impl OrchestratorState {
    pub fn transition_to(
        &mut self,
        new_state: OrchestratorRunState
    ) -> anyhow::Result<()> {
        let valid_transitions = match (self.run_state, new_state) {
            (OrchestratorRunState::Idle, OrchestratorRunState::Processing) => true,
            (OrchestratorRunState::Idle, OrchestratorRunState::Paused) => true,
            (OrchestratorRunState::Processing, OrchestratorRunState::Idle) => true,
            (OrchestratorRunState::Processing, OrchestratorRunState::Paused) => true,
            (OrchestratorRunState::Paused, OrchestratorRunState::Processing) => true,
            (OrchestratorRunState::Paused, OrchestratorRunState::Idle) => true,
            (OrchestratorRunState::Processing, OrchestratorRunState::Stopped) => true,
            (OrchestratorRunState::Paused, OrchestratorRunState::Stopped) => true,
            (OrchestratorRunState::Idle, OrchestratorRunState::Stopped) => true,
            (from, to) => {
                tracing::error!("Invalid state transition: {:?}  {:?}", from, to);
                false
            }
        };

        if valid_transitions {
            tracing::debug!("State transition: {:?}  {:?}", self.run_state, new_state);
            self.run_state = new_state;
            Ok(())
        } else {
            Err(anyhow::anyhow!(
                "Invalid state transition: {:?}  {:?}",
                self.run_state, new_state
            ))
        }
    }
}
```

**Step 2: Add tests**

```rust
#[test]
fn test_valid_state_transitions() {
    let mut state = OrchestratorState::new("test-workflow");

    // Idle -> Processing
    assert!(state.transition_to(OrchestratorRunState::Processing).is_ok());
    assert_eq!(state.run_state, OrchestratorRunState::Processing);

    // Processing -> Paused
    assert!(state.transition_to(OrchestratorRunState::Paused).is_ok());
    assert_eq!(state.run_state, OrchestratorRunState::Paused);

    // Paused -> Processing
    assert!(state.transition_to(OrchestratorRunState::Processing).is_ok());
}

#[test]
fn test_invalid_state_transitions() {
    let mut state = OrchestratorState::new("test-workflow");

    // Can't go from Idle to Stopped
    assert!(state.transition_to(OrchestratorRunState::Stopped).is_ok()); // This is valid per rules above

    // Reset
    state.run_state = OrchestratorRunState::Stopped;

    // Can't transition from Stopped
    assert!(state.transition_to(OrchestratorRunState::Processing).is_err());
}
```

**Step 3: Commit**

```bash
git add crates/services/src/services/orchestrator/state.rs
git commit -m "refactor(state): add explicit state transition validation"
```

---

### Task 16: LLM Prompt Template System (8.5.11)

**Files:**
- Create: `crates/services/src/services/orchestrator/templates/`
- Modify: `crates/services/src/services/orchestrator/llm.rs`

**Step 1: Add handlebars dependency**

```toml
# crates/services/Cargo.toml
handlebars = "5.0"
```

**Step 2: Create template files**

```handlebars
<!-- crates/services/src/services/orchestrator/templates/terminal_completion.hbs -->

Terminal {{terminal_id}} has completed task {{task_id}}.

Commit: {{commit_hash}}
Message: {{commit_message}}

Files Changed:
{{#each files_changed}}
  - {{path}} ({{changeType}})
{{/each}}

Please analyze the results and decide on the next step.
```

**Step 3: Implement template rendering**

```rust
// crates/services/src/services/orchestrator/llm.rs

use handlebars::Handlebars;
use lazy_static::lazy_static;

lazy_static! {
    static ref TEMPLATES: Handlebars<'static> = {
        let mut hb = Handlebars::new();

        // Register templates
        hb.register_template_string(
            "terminal_completion",
            include_str!("templates/terminal_completion.hbs")
        ).expect("Failed to load terminal_completion template");

        hb
    };
}

pub fn build_terminal_completion_prompt(
    event: &TerminalCompletionEvent
) -> anyhow::Result<String> {
    let data = serde_json::to_value(event)
        .map_err(|e| anyhow::anyhow!("Failed to serialize event: {}", e))?;

    TEMPLATES.render("terminal_completion", &data)
        .map_err(|e| anyhow::anyhow!("Failed to render template: {}", e))
}
```

**Step 4: Commit**

```bash
git add crates/services/Cargo.toml crates/services/src/services/orchestrator/
git commit -m "feat(orchestrator): add LLM prompt template system with Handlebars"
```

---

### Task 17: Database Batch Operations (8.5.12)

**Files:**
- Modify: `crates/db/src/models/workflow.rs`

**Step 1: Add batch create method**

```rust
impl Workflow {
    pub async fn create_with_tasks(
        pool: &SqlitePool,
        workflow: &Workflow,
        tasks: Vec<(WorkflowTask, Vec<Terminal>)>,
    ) -> anyhow::Result<()> {
        let mut tx = pool.begin().await?;

        // Create workflow
        sqlx::query(
            "INSERT INTO workflow (workflow_id, cli_type_id, status, created_at, updated_at, order_index)
             VALUES (?, ?, ?, ?, ?, ?)"
        )
        .bind(&workflow.workflow_id)
        .bind(&workflow.cli_type_id)
        .bind(&workflow.status)
        .bind(workflow.created_at)
        .bind(workflow.updated_at)
        .bind(workflow.order_index)
        .execute(&mut *tx)
        .await?;

        // Create tasks and terminals
        for (task, terminals) in tasks {
            sqlx::query(
                "INSERT INTO workflow_task (task_id, workflow_id, description, status, created_at, updated_at)
                 VALUES (?, ?, ?, ?, ?, ?)"
            )
            .bind(&task.task_id)
            .bind(&task.workflow_id)
            .bind(&task.description)
            .bind(&task.status)
            .bind(task.created_at)
            .bind(task.updated_at)
            .execute(&mut *tx)
            .await?;

            for terminal in terminals {
                sqlx::query(
                    "INSERT INTO terminal (terminal_id, task_id, status, created_at, updated_at)
                     VALUES (?, ?, ?, ?, ?)"
                )
                .bind(&terminal.terminal_id)
                .bind(&terminal.task_id)
                .bind(&terminal.status)
                .bind(terminal.created_at)
                .bind(terminal.updated_at)
                .execute(&mut *tx)
                .await?;
            }
        }

        tx.commit().await?;
        Ok(())
    }
}
```

**Step 2: Commit**

```bash
git add crates/db/src/models/workflow.rs
git commit -m "feat(db): add batch workflow creation with transactions"
```

---

### Task 18: WebSocket Connection Timeout (8.5.13)

**Files:**
- Modify: Terminal WebSocket connection code

**Step 1: Add timeout to PTY connection**

```rust
use tokio::time::{timeout, Duration};

const PTY_CONNECT_TIMEOUT_SECS: u64 = 30;

pub async fn connect_to_pty(
    terminal_id: &str
) -> anyhow::Result<WebSocketStream> {
    timeout(
        Duration::from_secs(PTY_CONNECT_TIMEOUT_SECS),
        do_connect_to_pty(terminal_id)
    )
    .await
    .map_err(|_| anyhow::anyhow!(
        "PTY connection timeout after {}s",
        PTY_CONNECT_TIMEOUT_SECS
    ))?
}
```

**Step 2: Commit**

```bash
git add crates/services/src/services/terminal_ws.rs
git commit -m "feat(terminal): add PTY connection timeout (30s)"
```

---

## FINAL VERIFICATION

### Task 19: Comprehensive Test Suite

**Step 1: Run full test suite**

```bash
cargo test --workspace
```

Expected: All tests pass

**Step 2: Run clippy**

```bash
cargo clippy --workspace -- -D warnings
```

Expected: No warnings

**Step 3: Run audit again**

```bash
# Run the code review agent
```

Expected: Grade improved from C to B or A

**Step 4: Final commit**

```bash
git add .
git commit -m "test: comprehensive test coverage for Phase 8.5 fixes"
```

---

## EXECUTION SUMMARY

This plan contains:
- **19 Tasks** covering all P0, P1, and P2 issues
- **50+ Individual steps** with exact commands
- **100% TDD approach** - every feature starts with failing test
- **Complete code snippets** - no "implement this" placeholders
- **Verification commands** for every task
- **Frequent commits** - commit after each task

**Estimated completion:** Full implementation, no shortcuts, production-ready code.

**Next Steps:**
1. Review this plan
2. Choose execution approach (Subagent-Driven vs Parallel Session)
3. Begin implementation task-by-task
