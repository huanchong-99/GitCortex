"use client";
import { jsx as K } from "react/jsx-runtime";
import { useId as Ve, useLayoutEffect as Ke, useEffect as Re, useRef as O, useCallback as Xe, createContext as Ye, useImperativeHandle as Ee, useState as I, useMemo as se, useSyncExternalStore as qe, useContext as Ze } from "react";
function z(e, t = "Assertion error") {
  if (!e)
    throw Error(t);
}
function B({
  group: e
}) {
  const { orientation: t, panels: n } = e;
  return n.reduce((o, r) => (o += t === "horizontal" ? r.element.offsetWidth : r.element.offsetHeight, o), 0);
}
function ae(e, t) {
  return t.sort(
    e === "horizontal" ? Je : Qe
  );
}
function Je(e, t) {
  const n = e.element.offsetLeft - t.element.offsetLeft;
  return n !== 0 ? n : e.element.offsetWidth - t.element.offsetWidth;
}
function Qe(e, t) {
  const n = e.element.offsetTop - t.element.offsetTop;
  return n !== 0 ? n : e.element.offsetHeight - t.element.offsetHeight;
}
function Me(e, t) {
  return {
    x: e.x >= t.left && e.x <= t.right ? 0 : Math.min(
      Math.abs(e.x - t.left),
      Math.abs(e.x - t.right)
    ),
    y: e.y >= t.top && e.y <= t.bottom ? 0 : Math.min(
      Math.abs(e.y - t.top),
      Math.abs(e.y - t.bottom)
    )
  };
}
function et({
  orientation: e,
  rects: t,
  targetRect: n
}) {
  const o = {
    x: n.x + n.width / 2,
    y: n.y + n.height / 2
  };
  let r, a = Number.MAX_VALUE;
  for (const l of t) {
    const { x: i, y: s } = Me(o, l), u = e === "horizontal" ? i : s;
    u < a && (a = u, r = l);
  }
  return z(r, "No rect found"), r;
}
function Ie(e) {
  const { element: t, orientation: n, panels: o, separators: r } = e, a = ae(
    n,
    Array.from(t.children).filter((c) => c instanceof HTMLElement).map((c) => ({ element: c }))
  ).map(({ element: c }) => c), l = [];
  let i = !1, s, u = [];
  for (const c of a)
    if (c.hasAttribute("data-panel")) {
      const h = o.find(
        (m) => m.element === c
      );
      if (h) {
        if (s) {
          const m = s.element.getBoundingClientRect(), p = c.getBoundingClientRect();
          let f;
          if (i) {
            const d = n === "horizontal" ? new DOMRect(m.right, m.top, 0, m.height) : new DOMRect(
              m.left,
              m.bottom,
              m.width,
              0
            ), g = n === "horizontal" ? new DOMRect(p.left, p.top, 0, p.height) : new DOMRect(p.left, p.top, p.width, 0);
            switch (u.length) {
              case 0: {
                f = [
                  d,
                  g
                ];
                break;
              }
              case 1: {
                const v = u[0], S = et({
                  orientation: n,
                  rects: [m, p],
                  targetRect: v.element.getBoundingClientRect()
                });
                f = [
                  v,
                  S === m ? g : d
                ];
                break;
              }
              default: {
                f = u;
                break;
              }
            }
          } else
            u.length ? f = u : f = [
              n === "horizontal" ? new DOMRect(
                m.right,
                p.top,
                p.left - m.right,
                p.height
              ) : new DOMRect(
                p.left,
                m.bottom,
                p.width,
                p.top - m.bottom
              )
            ];
          for (const d of f)
            l.push({
              group: e,
              groupSize: B({ group: e }),
              panels: [s, h],
              separator: "width" in d ? void 0 : d,
              rect: "width" in d ? d : d.element.getBoundingClientRect()
            });
        }
        i = !1, s = h, u = [];
      }
    } else if (c.hasAttribute("data-separator")) {
      const h = r.find(
        (m) => m.element === c
      );
      h ? u.push(h) : (s = void 0, u = []);
    } else
      i = !0;
  return l;
}
function tt(e, t) {
  const n = getComputedStyle(e), o = parseFloat(n.fontSize);
  return t * o;
}
function nt(e, t) {
  const n = getComputedStyle(e.ownerDocument.body), o = parseFloat(n.fontSize);
  return t * o;
}
function ot(e) {
  return e / 100 * window.innerHeight;
}
function it(e) {
  return e / 100 * window.innerWidth;
}
function rt(e) {
  switch (typeof e) {
    case "number":
      return [e, "px"];
    case "string": {
      const t = parseFloat(e);
      return e.endsWith("%") ? [t, "%"] : e.endsWith("px") ? [t, "px"] : e.endsWith("rem") ? [t, "rem"] : e.endsWith("em") ? [t, "em"] : e.endsWith("vh") ? [t, "vh"] : e.endsWith("vw") ? [t, "vw"] : [t, "%"];
    }
  }
}
function te({
  groupSize: e,
  panelElement: t,
  styleProp: n
}) {
  let o;
  const [r, a] = rt(n);
  switch (a) {
    case "%": {
      o = r / 100 * e;
      break;
    }
    case "px": {
      o = r;
      break;
    }
    case "rem": {
      o = nt(t, r);
      break;
    }
    case "em": {
      o = tt(t, r);
      break;
    }
    case "vh": {
      o = ot(r);
      break;
    }
    case "vw": {
      o = it(r);
      break;
    }
  }
  return o;
}
function k(e) {
  return parseFloat(e.toFixed(3));
}
function ge(e) {
  const { panels: t } = e, n = B({ group: e });
  return n === 0 ? t.map((o) => ({
    collapsedSize: 0,
    collapsible: o.panelConstraints.collapsible === !0,
    defaultSize: void 0,
    minSize: 0,
    maxSize: 100,
    panelId: o.id
  })) : t.map((o) => {
    const { element: r, panelConstraints: a } = o;
    let l = 0;
    if (a.collapsedSize) {
      const c = te({
        groupSize: n,
        panelElement: r,
        styleProp: a.collapsedSize
      });
      l = k(c / n * 100);
    }
    let i;
    if (a.defaultSize) {
      const c = te({
        groupSize: n,
        panelElement: r,
        styleProp: a.defaultSize
      });
      i = k(c / n * 100);
    }
    let s = 0;
    if (a.minSize) {
      const c = te({
        groupSize: n,
        panelElement: r,
        styleProp: a.minSize
      });
      s = k(c / n * 100);
    }
    let u = 100;
    if (a.maxSize) {
      const c = te({
        groupSize: n,
        panelElement: r,
        styleProp: a.maxSize
      });
      u = k(c / n * 100);
    }
    return {
      collapsedSize: l,
      collapsible: a.collapsible === !0,
      defaultSize: i,
      minSize: s,
      maxSize: u,
      panelId: o.id
    };
  });
}
class st {
  #e = {};
  addListener(t, n) {
    const o = this.#e[t];
    return o === void 0 ? this.#e[t] = [n] : o.includes(n) || o.push(n), () => {
      this.removeListener(t, n);
    };
  }
  emit(t, n) {
    const o = this.#e[t];
    if (o !== void 0)
      if (o.length === 1)
        o[0].call(null, n);
      else {
        let r = !1, a = null;
        const l = Array.from(o);
        for (let i = 0; i < l.length; i++) {
          const s = l[i];
          try {
            s.call(null, n);
          } catch (u) {
            a === null && (r = !0, a = u);
          }
        }
        if (r)
          throw a;
      }
  }
  removeAllListeners() {
    this.#e = {};
  }
  removeListener(t, n) {
    const o = this.#e[t];
    if (o !== void 0) {
      const r = o.indexOf(n);
      r >= 0 && o.splice(r, 1);
    }
  }
}
function P(e, t, n = 0) {
  return Math.abs(k(e) - k(t)) <= n;
}
let R = {
  cursorFlags: 0,
  interactionState: {
    state: "inactive"
  },
  mountedGroups: /* @__PURE__ */ new Map()
};
const _ = new st();
function D() {
  return R;
}
function E(e) {
  const t = typeof e == "function" ? e(R) : e;
  if (R === t)
    return R;
  const n = R;
  return R = {
    ...R,
    ...t
  }, t.cursorFlags !== void 0 && _.emit("cursorFlagsChange", R.cursorFlags), t.interactionState !== void 0 && _.emit("interactionStateChange", R.interactionState), t.mountedGroups !== void 0 && (R.mountedGroups.forEach((o, r) => {
    o.derivedPanelConstraints.forEach((a) => {
      if (a.collapsible) {
        const { layout: l } = n.mountedGroups.get(r) ?? {};
        if (l) {
          const i = P(
            a.collapsedSize,
            o.layout[a.panelId]
          ), s = P(
            a.collapsedSize,
            l[a.panelId]
          );
          i && !s && (r.inMemoryLastExpandedPanelSizes[a.panelId] = l[a.panelId]);
        }
      }
    });
  }), _.emit("mountedGroupsChange", R.mountedGroups)), R;
}
const at = (e) => e, ie = () => {
}, ke = 1, Ge = 2, De = 4, Oe = 8, ye = {
  coarse: 10,
  precise: 5
};
function lt({
  cursorFlags: e,
  groups: t,
  state: n
}) {
  let o = 0, r = 0;
  switch (n) {
    case "active":
    case "hover":
      t.forEach((a) => {
        if (!a.disableCursor)
          switch (a.orientation) {
            case "horizontal": {
              o++;
              break;
            }
            case "vertical": {
              r++;
              break;
            }
          }
      });
  }
  if (o === 0 && r === 0)
    return null;
  switch (n) {
    case "active": {
      const a = (e & ke) !== 0, l = (e & Ge) !== 0, i = (e & De) !== 0, s = (e & Oe) !== 0;
      if (e) {
        if (a)
          return i ? "se-resize" : s ? "ne-resize" : "e-resize";
        if (l)
          return i ? "sw-resize" : s ? "nw-resize" : "w-resize";
        if (i)
          return "s-resize";
        if (s)
          return "n-resize";
      }
      break;
    }
  }
  return o > 0 && r > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize";
}
let re, G;
function le() {
  G === void 0 && (G = new CSSStyleSheet(), document.adoptedStyleSheets = [G]);
  const { cursorFlags: e, interactionState: t } = D();
  switch (t.state) {
    case "active":
    case "hover": {
      const n = lt({
        cursorFlags: e,
        groups: t.hitRegions.map((r) => r.group),
        state: t.state
      }), o = `*{cursor: ${n} !important; ${t.state === "active" ? "touch-action: none;" : ""} }`;
      if (re === o)
        return;
      re = o, n ? G.cssRules.length === 0 ? G.insertRule(o) : G.replaceSync(o) : G.cssRules.length === 1 && G.deleteRule(0);
      break;
    }
    case "inactive": {
      re = void 0, G.cssRules.length === 1 && G.deleteRule(0);
      break;
    }
  }
}
function ut(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function X(e, t) {
  return P(e, t) ? 0 : e > t ? 1 : -1;
}
function W({
  panelConstraints: e,
  size: t
}) {
  const {
    collapsedSize: n = 0,
    collapsible: o,
    maxSize: r = 100,
    minSize: a = 0
  } = e;
  if (X(t, a) < 0)
    if (o) {
      const l = (n + a) / 2;
      X(t, l) < 0 ? t = n : t = a;
    } else
      t = a;
  return t = Math.min(r, t), t = k(t), t;
}
function Y({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: r,
  trigger: a
}) {
  if (P(e, 0))
    return t;
  const l = Object.values(t), i = Object.values(r), s = [...l], [u, c] = o;
  z(u != null, "Invalid first pivot index"), z(c != null, "Invalid second pivot index");
  let h = 0;
  if (a === "keyboard") {
    {
      const f = e < 0 ? c : u, d = n[f];
      z(
        d,
        `Panel constraints not found for index ${f}`
      );
      const {
        collapsedSize: g = 0,
        collapsible: v,
        minSize: S = 0
      } = d;
      if (v) {
        const x = l[f];
        if (z(
          x != null,
          `Previous layout not found for panel index ${f}`
        ), P(x, g)) {
          const y = S - x;
          X(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
        }
      }
    }
    {
      const f = e < 0 ? u : c, d = n[f];
      z(
        d,
        `No panel constraints found for index ${f}`
      );
      const {
        collapsedSize: g = 0,
        collapsible: v,
        minSize: S = 0
      } = d;
      if (v) {
        const x = l[f];
        if (z(
          x != null,
          `Previous layout not found for panel index ${f}`
        ), P(x, S)) {
          const y = x - g;
          X(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
        }
      }
    }
  }
  {
    const f = e < 0 ? 1 : -1;
    let d = e < 0 ? c : u, g = 0;
    for (; ; ) {
      const S = l[d];
      z(
        S != null,
        `Previous layout not found for panel index ${d}`
      );
      const y = W({
        panelConstraints: n[d],
        size: 100
      }) - S;
      if (g += y, d += f, d < 0 || d >= n.length)
        break;
    }
    const v = Math.min(Math.abs(e), Math.abs(g));
    e = e < 0 ? 0 - v : v;
  }
  {
    let d = e < 0 ? u : c;
    for (; d >= 0 && d < n.length; ) {
      const g = Math.abs(e) - Math.abs(h), v = l[d];
      z(
        v != null,
        `Previous layout not found for panel index ${d}`
      );
      const S = v - g, x = W({
        panelConstraints: n[d],
        size: S
      });
      if (!P(v, x) && (h += v - x, s[d] = x, h.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? d-- : d++;
    }
  }
  if (ut(i, s))
    return r;
  {
    const f = e < 0 ? c : u, d = l[f];
    z(
      d != null,
      `Previous layout not found for panel index ${f}`
    );
    const g = d + h, v = W({
      panelConstraints: n[f],
      size: g
    });
    if (s[f] = v, !P(v, g)) {
      let S = g - v, y = e < 0 ? c : u;
      for (; y >= 0 && y < n.length; ) {
        const b = s[y];
        z(
          b != null,
          `Previous layout not found for panel index ${y}`
        );
        const L = b + S, C = W({
          panelConstraints: n[y],
          size: L
        });
        if (P(b, C) || (S -= C - b, s[y] = C), P(S, 0))
          break;
        e > 0 ? y-- : y++;
      }
    }
  }
  const m = Object.values(s).reduce(
    (f, d) => d + f,
    0
  );
  if (!P(m, 100, 0.1))
    return r;
  const p = Object.keys(r);
  return s.reduce((f, d, g) => (f[p[g]] = d, f), {});
}
function U(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (t[n] === void 0 || X(e[n], t[n]) !== 0)
      return !1;
  return !0;
}
function Te({
  event: e,
  hitRegions: t,
  initialLayoutMap: n,
  mountedGroups: o,
  pointerDownAtPoint: r
}) {
  let a = 0;
  const l = new Map(o);
  t.forEach((i) => {
    const { group: s, groupSize: u } = i, { disableCursor: c, orientation: h, panels: m } = s;
    let p = 0;
    r ? h === "horizontal" ? p = (e.clientX - r.x) / u * 100 : p = (e.clientY - r.y) / u * 100 : h === "horizontal" ? p = e.clientX < 0 ? -100 : 100 : p = e.clientY < 0 ? -100 : 100;
    const f = n.get(s), {
      defaultLayoutDeferred: d,
      derivedPanelConstraints: g,
      layout: v,
      separatorToPanels: S
    } = o.get(s) ?? { defaultLayoutDeferred: !1 };
    if (g && f && v && S) {
      const x = Y({
        delta: p,
        initialLayout: f,
        panelConstraints: g,
        pivotIndices: i.panels.map((y) => m.indexOf(y)),
        prevLayout: v,
        trigger: "mouse-or-touch"
      });
      if (U(x, v)) {
        if (p !== 0 && !c)
          switch (h) {
            case "horizontal": {
              a |= p < 0 ? ke : Ge;
              break;
            }
            case "vertical": {
              a |= p < 0 ? De : Oe;
              break;
            }
          }
      } else {
        l.set(i.group, {
          defaultLayoutDeferred: d,
          derivedPanelConstraints: g,
          layout: x,
          separatorToPanels: S
        });
        const y = i.group.panels.map(({ id: b }) => b).join(",");
        i.group.inMemoryLayouts[y] = x;
      }
    }
  }), E({
    cursorFlags: a,
    mountedGroups: l
  }), le();
}
function ve(e) {
  if (e.defaultPrevented)
    return;
  if (e.relatedTarget !== null)
    return;
  if (e.clientX === 0 && e.clientY === 0)
    return;
  const { interactionState: t, mountedGroups: n } = D();
  switch (t.state) {
    case "active":
      t.hitRegions.forEach((o) => {
        e.currentTarget === o.group.element && Te({
          event: e,
          hitRegions: t.hitRegions,
          initialLayoutMap: t.initialLayoutMap,
          mountedGroups: n
        });
      });
  }
}
function oe(e) {
  const t = e.parentElement;
  z(t, "Parent group element not found");
  const { mountedGroups: n } = D();
  for (const [o] of n)
    if (o.element === t)
      return o;
  throw Error("Could not find parent Group for separator element");
}
function A({
  layout: e,
  panelConstraints: t
}) {
  const o = [...Object.values(e)], r = o.reduce(
    (i, s) => i + s,
    0
  );
  if (o.length !== t.length)
    throw Error(
      `Invalid ${t.length} panel layout: ${o.map((i) => `${i}%`).join(", ")}`
    );
  if (!P(r, 100) && o.length > 0)
    for (let i = 0; i < t.length; i++) {
      const s = o[i];
      z(s != null, `No layout data found for index ${i}`);
      const u = 100 / r * s;
      o[i] = u;
    }
  let a = 0;
  for (let i = 0; i < t.length; i++) {
    const s = o[i];
    z(s != null, `No layout data found for index ${i}`);
    const u = W({
      panelConstraints: t[i],
      size: s
    });
    s != u && (a += s - u, o[i] = u);
  }
  if (!P(a, 0))
    for (let i = 0; i < t.length; i++) {
      const s = o[i];
      z(s != null, `No layout data found for index ${i}`);
      const u = s + a, c = W({
        panelConstraints: t[i],
        size: u
      });
      if (s !== c && (a -= c - s, o[i] = c, P(a, 0)))
        break;
    }
  const l = Object.keys(e);
  return o.reduce((i, s, u) => (i[l[u]] = s, i), {});
}
function _e({
  groupId: e
}) {
  const t = () => {
    const { mountedGroups: n } = D();
    for (const [o, r] of n)
      if (o.id === e)
        return { group: o, ...r };
    throw Error(`Could not find Group with id "${e}"`);
  };
  return {
    getLayout() {
      const { defaultLayoutDeferred: n, layout: o } = t();
      return n ? {} : o;
    },
    setLayout(n) {
      const {
        defaultLayoutDeferred: o,
        derivedPanelConstraints: r,
        group: a,
        layout: l,
        separatorToPanels: i
      } = t(), s = A({
        layout: n,
        panelConstraints: r
      });
      return o ? l : (U(l, s) || E((u) => ({
        mountedGroups: new Map(u.mountedGroups).set(a, {
          defaultLayoutDeferred: o,
          derivedPanelConstraints: r,
          layout: s,
          separatorToPanels: i
        })
      })), s);
    }
  };
}
function Ae(e) {
  const { mountedGroups: t } = D(), n = t.get(e);
  return z(n, `Mounted Group ${e.id} not found`), n;
}
function T(e, t) {
  const n = oe(e), o = Ae(n), r = n.separators.find(
    (h) => h.element === e
  );
  z(r, "Matching separator not found");
  const a = o.separatorToPanels.get(r);
  z(a, "Matching panels not found");
  const l = a.map((h) => n.panels.indexOf(h)), s = _e({ groupId: n.id }).getLayout(), u = Y({
    delta: t,
    initialLayout: s,
    panelConstraints: o.derivedPanelConstraints,
    pivotIndices: l,
    prevLayout: s,
    trigger: "keyboard"
  }), c = A({
    layout: u,
    panelConstraints: o.derivedPanelConstraints
  });
  U(s, c) || E((h) => ({
    mountedGroups: new Map(h.mountedGroups).set(n, {
      defaultLayoutDeferred: o.defaultLayoutDeferred,
      derivedPanelConstraints: o.derivedPanelConstraints,
      layout: c,
      separatorToPanels: o.separatorToPanels
    })
  }));
}
function Se(e) {
  if (e.defaultPrevented)
    return;
  const t = e.currentTarget, n = oe(t);
  if (!n.disabled)
    switch (e.key) {
      case "ArrowDown": {
        e.preventDefault(), n.orientation === "vertical" && T(t, 5);
        break;
      }
      case "ArrowLeft": {
        e.preventDefault(), n.orientation === "horizontal" && T(t, -5);
        break;
      }
      case "ArrowRight": {
        e.preventDefault(), n.orientation === "horizontal" && T(t, 5);
        break;
      }
      case "ArrowUp": {
        e.preventDefault(), n.orientation === "vertical" && T(t, -5);
        break;
      }
      case "End": {
        e.preventDefault(), T(t, 100);
        break;
      }
      case "Enter": {
        e.preventDefault();
        const o = oe(t), { derivedPanelConstraints: r, layout: a, separatorToPanels: l } = Ae(o), i = o.separators.find(
          (h) => h.element === t
        );
        z(i, "Matching separator not found");
        const s = l.get(i);
        z(s, "Matching panels not found");
        const u = s[0], c = r.find(
          (h) => h.panelId === u.id
        );
        if (z(c, "Panel metadata not found"), c.collapsible) {
          const h = a[u.id], m = c.collapsedSize === h ? o.inMemoryLastExpandedPanelSizes[u.id] ?? c.minSize : c.collapsedSize;
          T(t, m - h);
        }
        break;
      }
      case "F6": {
        e.preventDefault();
        const r = oe(t).separators.map(
          (s) => s.element
        ), a = Array.from(r).findIndex(
          (s) => s === e.currentTarget
        );
        z(a !== null, "Index not found");
        const l = e.shiftKey ? a > 0 ? a - 1 : r.length - 1 : a + 1 < r.length ? a + 1 : 0;
        r[l].focus();
        break;
      }
      case "Home": {
        e.preventDefault(), T(t, -100);
        break;
      }
    }
}
function ct(e, t, n) {
  let o, r = {
    x: 1 / 0,
    y: 1 / 0
  };
  for (const a of t) {
    const l = Me(n, a.rect);
    switch (e) {
      case "horizontal": {
        l.x <= r.x && (o = a, r = l);
        break;
      }
      case "vertical": {
        l.y <= r.y && (o = a, r = l);
        break;
      }
    }
  }
  return o ? {
    distance: r,
    hitRegion: o
  } : void 0;
}
let ne;
function ft() {
  return ne === void 0 && (typeof matchMedia == "function" ? ne = !!matchMedia("(pointer:coarse)").matches : ne = !1), ne;
}
function dt(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: we(e),
    b: we(t)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), o = e;
  z(
    o,
    "Stacking order can only be calculated for elements with a common ancestor"
  );
  const r = {
    a: ze(xe(n.a)),
    b: ze(xe(n.b))
  };
  if (r.a === r.b) {
    const a = o.childNodes, l = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = a.length;
    for (; i--; ) {
      const s = a[i];
      if (s === l.a) return 1;
      if (s === l.b) return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const pt = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function ht(e) {
  const t = getComputedStyle(Ne(e) ?? e).display;
  return t === "flex" || t === "inline-flex";
}
function mt(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || ht(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || pt.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function xe(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (z(n, "Missing node"), mt(n)) return n;
  }
  return null;
}
function ze(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function we(e) {
  const t = [];
  for (; e; )
    t.push(e), e = Ne(e);
  return t;
}
function Ne(e) {
  const { parentNode: t } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
function gt(e, t) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function yt({
  groupElement: e,
  hitRegion: t,
  pointerEventTarget: n
}) {
  if (!(n instanceof HTMLElement) || n.contains(e) || e.contains(n))
    return !0;
  if (dt(n, e) > 0) {
    let o = n;
    for (; o; ) {
      if (o.contains(e))
        return !0;
      if (gt(o.getBoundingClientRect(), t))
        return !1;
      o = o.parentElement;
    }
  }
  return !0;
}
function $e(e, t) {
  const n = [];
  return t.forEach((o, r) => {
    if (r.disabled)
      return;
    const a = ft() ? ye.coarse : ye.precise, l = Ie(r), i = ct(r.orientation, l, {
      x: e.clientX,
      y: e.clientY
    });
    i && i.distance.x <= a && i.distance.y <= a && yt({
      groupElement: r.element,
      hitRegion: i.hitRegion.rect,
      pointerEventTarget: e.target
    }) && n.push(i.hitRegion);
  }), n;
}
function be(e) {
  if (e.defaultPrevented)
    return;
  const { mountedGroups: t } = D(), n = $e(e, t), o = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
  let i = !1;
  n.forEach((s) => {
    o.add(s.group), s.panels.forEach((c) => {
      r.add(c);
    }), s.separator && (a.add(s.separator), i || (i = !0, s.separator.element.focus()));
    const u = t.get(s.group);
    u && l.set(s.group, u.layout);
  }), E({
    interactionState: {
      hitRegions: n,
      initialLayoutMap: l,
      pointerDownAtPoint: { x: e.clientX, y: e.clientY },
      state: "active"
    }
  }), n.length && e.preventDefault();
}
function Le(e) {
  if (e.defaultPrevented)
    return;
  const { interactionState: t, mountedGroups: n } = D();
  switch (t.state) {
    case "active": {
      if (
        // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
        e.type !== "pointerleave" && e.buttons === 0
      ) {
        E(
          (o) => o.interactionState.state === "inactive" ? o : {
            cursorFlags: 0,
            interactionState: {
              state: "inactive"
            }
          }
        );
        return;
      }
      Te({
        event: e,
        hitRegions: t.hitRegions,
        initialLayoutMap: t.initialLayoutMap,
        mountedGroups: n,
        pointerDownAtPoint: t.pointerDownAtPoint
      });
      break;
    }
    default: {
      const o = $e(e, n);
      o.length === 0 ? t.state !== "inactive" && E({
        interactionState: { state: "inactive" }
      }) : E({
        interactionState: {
          hitRegions: o,
          state: "hover"
        }
      }), le();
      break;
    }
  }
}
function Pe(e) {
  if (e.defaultPrevented)
    return;
  e.preventDefault();
  const { interactionState: t } = D();
  switch (t.state) {
    case "active":
      E({
        cursorFlags: 0,
        interactionState: {
          state: "inactive"
        }
      }), le();
  }
}
function Ce(e) {
  let t = 0, n = 0;
  const o = {};
  for (const a of e)
    if (a.defaultSize !== void 0) {
      t++;
      const l = k(a.defaultSize);
      n += l, o[a.panelId] = l;
    } else
      o[a.panelId] = void 0;
  const r = e.length - t;
  if (r !== 0) {
    const a = k((100 - n) / r);
    for (const l of e)
      l.defaultSize === void 0 && (o[l.panelId] = a);
  }
  return o;
}
function vt(e, t, n) {
  const o = n[0];
  if (!o)
    return;
  const r = e.panels.find((l) => l.element === t);
  if (!r || !r.onResize)
    return;
  const a = B({ group: e });
  r.onResize(
    {
      asPercentage: k(
        o.inlineSize / a * 100
      ),
      inPixels: o.inlineSize
    },
    r.id
  );
}
function St(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const o in e)
    if (e[o] !== t[o])
      return !1;
  return !0;
}
function xt(e) {
  let t = !0;
  const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = new ResizeObserver((p) => {
    for (const f of p) {
      const { borderBoxSize: d, target: g } = f;
      if (g === e.element) {
        if (t) {
          if (B({ group: e }) === 0)
            return;
          E((S) => {
            const x = S.mountedGroups.get(e);
            if (x) {
              const y = ge(e), b = x.defaultLayoutDeferred ? Ce(y) : x.layout, L = A({
                layout: b,
                panelConstraints: y
              });
              return !x.defaultLayoutDeferred && U(b, L) && St(
                x.derivedPanelConstraints,
                y
              ) ? S : {
                mountedGroups: new Map(S.mountedGroups).set(e, {
                  defaultLayoutDeferred: !1,
                  derivedPanelConstraints: y,
                  layout: L,
                  separatorToPanels: x.separatorToPanels
                })
              };
            }
            return S;
          });
        }
      } else
        vt(e, g, d);
    }
  });
  r.observe(e.element), e.panels.forEach((p) => {
    z(
      !n.has(p.id),
      `Panel ids must be unique; id "${p.id}" was used more than once`
    ), n.add(p.id), p.onResize && r.observe(p.element);
  });
  const a = B({ group: e }), l = ge(e), i = e.panels.map(({ id: p }) => p).join(",");
  let s = e.defaultLayout;
  s && e.panels.length !== Object.keys(s).length && (s = void 0);
  const u = e.inMemoryLayouts[i] ?? s ?? Ce(l), c = A({
    layout: u,
    panelConstraints: l
  }), h = Ie(e), m = E((p) => {
    const f = /* @__PURE__ */ new Map();
    return h.forEach((d) => {
      d.separator && f.set(d.separator, d.panels);
    }), {
      mountedGroups: new Map(p.mountedGroups).set(e, {
        defaultLayoutDeferred: a === 0,
        derivedPanelConstraints: l,
        layout: c,
        separatorToPanels: f
      })
    };
  });
  return e.element.addEventListener("pointerleave", ve), e.separators.forEach((p) => {
    z(
      !o.has(p.id),
      `Separator ids must be unique; id "${p.id}" was used more than once`
    ), o.add(p.id), p.element.addEventListener("keydown", Se);
  }), m.mountedGroups.size === 1 && (window.addEventListener("pointerdown", be), window.addEventListener("pointermove", Le), window.addEventListener("pointerup", Pe)), function() {
    t = !1;
    const f = E((d) => {
      const g = new Map(d.mountedGroups);
      return g.delete(e), { mountedGroups: g };
    });
    e.element.removeEventListener("pointerleave", ve), e.separators.forEach((d) => {
      d.element.removeEventListener("keydown", Se);
    }), f.mountedGroups.size === 0 && (window.removeEventListener("pointerdown", be), window.removeEventListener("pointermove", Le), window.removeEventListener("pointerup", Pe)), r.disconnect();
  };
}
function ue(e) {
  const t = Ve();
  return `${e ?? t}`;
}
const N = typeof window < "u" ? Ke : Re;
function ce(e) {
  const t = O(e);
  return N(() => {
    t.current = e;
  }, [e]), Xe((n) => t.current?.(n), [t]);
}
function fe(...e) {
  return ce((t) => {
    e.forEach((n) => {
      if (n)
        switch (typeof n) {
          case "function": {
            n(t);
            break;
          }
          case "object": {
            n.current = t;
            break;
          }
        }
    });
  });
}
function zt(e) {
  const t = O({ ...e });
  return N(() => {
    for (const n in e)
      t.current[n] = e[n];
  }, [e]), t.current;
}
const Fe = "--react-resizable-panels--panel--pointer-events";
function He(e, t) {
  const n = e.replace(/[^a-zA-Z0-9\-_]/g, ""), o = t.replace(/[^a-zA-Z0-9\-_]/g, "");
  return `--react-resizable-panels--${n}--${o}`;
}
const je = Ye(null);
function wt(e, t) {
  const n = O({
    getLayout: () => ({}),
    setLayout: at
  });
  Ee(t, () => n.current, []), N(() => {
    Object.assign(
      n.current,
      _e({ groupId: e })
    );
  });
}
function Gt({
  children: e,
  className: t,
  defaultLayout: n,
  disableCursor: o,
  disabled: r,
  elementRef: a,
  groupRef: l,
  id: i,
  onLayoutChange: s,
  orientation: u = "horizontal",
  style: c,
  ...h
}) {
  const m = O({}), p = ce((w) => {
    U(m.current, w) || (m.current = w, s?.(w));
  }), f = ue(i), [d, g] = I(!1), [v, S] = I(null), [x, y] = I(n ?? {}), [b, L] = I([]), [C, q] = I([]), Z = O({
    lastExpandedPanelSizes: {},
    layouts: {}
  }), J = fe(S, a);
  wt(f, l);
  const Q = se(
    () => ({
      id: f,
      orientation: u,
      registerPanel: (w) => (L((M) => ae(u, [...M, w])), () => {
        L((M) => M.filter((F) => F !== w));
      }),
      registerSeparator: (w) => (q(
        (M) => ae(u, [...M, w])
      ), () => {
        q(
          (M) => M.filter((F) => F !== w)
        );
      })
    }),
    [f, u]
  ), $ = zt({
    defaultLayout: n,
    disableCursor: o
  }), V = O(null);
  N(() => {
    if (v === null)
      return;
    const w = {
      defaultLayout: $.defaultLayout,
      disableCursor: !!$.disableCursor,
      disabled: !!r,
      element: v,
      id: f,
      inMemoryLastExpandedPanelSizes: Z.current.lastExpandedPanelSizes,
      inMemoryLayouts: Z.current.layouts,
      orientation: u,
      panels: b,
      separators: C
    };
    V.current = w;
    const M = xt(w), he = D().mountedGroups.get(w);
    if (he) {
      const { defaultLayoutDeferred: H, derivedPanelConstraints: j, layout: ee } = he;
      !H && j.length > 0 && (y(ee), p?.(ee));
    }
    const We = _.addListener(
      "interactionStateChange",
      (H) => {
        switch (H.state) {
          case "active": {
            g(
              H.hitRegions.some(
                (j) => j.group === w
              )
            );
            break;
          }
          default: {
            g(!1);
            break;
          }
        }
      }
    ), Be = _.addListener(
      "mountedGroupsChange",
      (H) => {
        const j = H.get(w);
        if (j) {
          const { defaultLayoutDeferred: ee, derivedPanelConstraints: Ue, layout: me } = j;
          if (ee || Ue.length === 0)
            return;
          y(me), p?.(me);
        }
      }
    );
    return () => {
      V.current = null, M(), We(), Be();
    };
  }, [
    r,
    v,
    f,
    p,
    u,
    b,
    C,
    $
  ]), Re(() => {
    const w = V.current;
    w && (w.defaultLayout = n, w.disableCursor = !!o);
  });
  const pe = {
    [Fe]: d ? "none" : void 0
  };
  for (const w in x) {
    const M = He(f, w), F = x[w];
    pe[M] = F;
  }
  return /* @__PURE__ */ K(je.Provider, { value: Q, children: /* @__PURE__ */ K(
    "div",
    {
      ...h,
      "aria-orientation": u,
      className: t,
      "data-group": !0,
      "data-testid": f,
      id: f,
      ref: J,
      style: {
        ...c,
        ...pe,
        display: "flex",
        flexDirection: u === "horizontal" ? "row" : "column",
        flexWrap: "nowrap"
      },
      children: e
    }
  ) });
}
function bt(e, t = 10) {
  let n = null;
  return (o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(o);
    }, t);
  };
}
function Lt(e) {
  return `react-resizable-panels:${e}`;
}
function Dt({
  debounceSaveMs: e = 100,
  storage: t,
  ...n
}) {
  const o = "id" in n ? n.id : n.groupId, r = Lt(o), a = qe(
    Pt,
    () => t.getItem(r),
    () => t.getItem(r)
  ), l = se(
    () => a ? JSON.parse(a) : void 0,
    [a]
  ), i = se(() => {
    const s = (u) => {
      try {
        t.setItem(r, JSON.stringify(u));
      } catch (c) {
        console.error(c);
      }
    };
    return e > 0 ? bt(s, e) : s;
  }, [e, t, r]);
  return {
    defaultLayout: l,
    onLayoutChange: i
  };
}
function Pt() {
  return function() {
  };
}
function Ot() {
  return I(null);
}
function Tt() {
  return O(null);
}
function de() {
  const e = Ze(je);
  return z(
    e,
    "Group Context not found; did you render a Panel or Separator outside of a Group?"
  ), e;
}
function Ct({
  groupId: e,
  panelId: t
}) {
  const n = () => {
    const { mountedGroups: i } = D();
    for (const [
      s,
      {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: h,
        separatorToPanels: m
      }
    ] of i)
      if (s.id === e)
        return {
          defaultLayoutDeferred: u,
          derivedPanelConstraints: c,
          group: s,
          layout: h,
          separatorToPanels: m
        };
    throw Error(`Group ${e} not found`);
  }, o = () => {
    const i = n().derivedPanelConstraints.find(
      (s) => s.panelId === t
    );
    if (i !== void 0)
      return i;
    throw Error(`Panel constraints not found for Panel ${t}`);
  }, r = () => {
    const i = n().group.panels.find((s) => s.id === t);
    if (i !== void 0)
      return i;
    throw Error(`Layout not found for Panel ${t}`);
  }, a = () => {
    const i = n().layout[t];
    if (i !== void 0)
      return i;
    throw Error(`Layout not found for Panel ${t}`);
  }, l = (i) => {
    const s = a();
    if (i === s)
      return;
    const {
      defaultLayoutDeferred: u,
      derivedPanelConstraints: c,
      group: h,
      layout: m,
      separatorToPanels: p
    } = n(), f = h.panels.findIndex((S) => S.id === t), d = f === h.panels.length - 1, g = Y({
      delta: d ? s - i : i - s,
      initialLayout: m,
      panelConstraints: c,
      pivotIndices: d ? [f - 1, f] : [f, f + 1],
      prevLayout: m,
      trigger: "imperative-api"
    }), v = A({
      layout: g,
      panelConstraints: c
    });
    U(m, v) || E((S) => ({
      mountedGroups: new Map(S.mountedGroups).set(h, {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: v,
        separatorToPanels: p
      })
    }));
  };
  return {
    collapse: () => {
      const { collapsible: i, collapsedSize: s } = o(), u = a();
      i && u !== s && l(s);
    },
    expand: () => {
      const { collapsible: i, collapsedSize: s, minSize: u } = o(), c = a();
      i && c === s && l(u);
    },
    getSize: () => {
      const { group: i } = n(), s = a(), { element: u } = r(), c = i.orientation === "horizontal" ? u.offsetWidth : u.offsetHeight;
      return {
        asPercentage: s,
        inPixels: c
      };
    },
    isCollapsed: () => {
      const { collapsible: i, collapsedSize: s } = o(), u = a();
      return i && P(s, u);
    },
    resize: (i) => {
      if (a() !== i) {
        let u;
        switch (typeof i) {
          case "number": {
            const { group: c } = n(), h = B({ group: c });
            u = k(i / h * 100);
            break;
          }
          case "string": {
            u = parseFloat(i);
            break;
          }
        }
        l(u);
      }
    }
  };
}
function Rt(e, t) {
  const { id: n } = de(), o = O({
    collapse: ie,
    expand: ie,
    getSize: () => ({
      asPercentage: 0,
      inPixels: 0
    }),
    isCollapsed: () => !1,
    resize: ie
  });
  Ee(t, () => o.current, []), N(() => {
    Object.assign(
      o.current,
      Ct({ groupId: n, panelId: e })
    );
  });
}
function _t({
  children: e,
  className: t,
  collapsedSize: n = "0%",
  collapsible: o = !1,
  defaultSize: r,
  elementRef: a,
  id: l,
  maxSize: i = "100%",
  minSize: s = "0%",
  onResize: u,
  panelRef: c,
  style: h,
  ...m
}) {
  const p = !!l, f = ue(l), [d, g] = I(null), v = fe(g, a), { id: S, registerPanel: x } = de(), y = u !== null, b = ce((C) => {
    u?.(C, l);
  });
  N(() => {
    if (d !== null)
      return x({
        element: d,
        id: f,
        idIsStable: p,
        onResize: y ? b : void 0,
        panelConstraints: {
          collapsedSize: n,
          collapsible: o,
          defaultSize: r,
          maxSize: i,
          minSize: s
        }
      });
  }, [
    n,
    o,
    r,
    d,
    y,
    f,
    p,
    i,
    s,
    b,
    x
  ]), Rt(f, c);
  const L = He(S, f);
  return /* @__PURE__ */ K(
    "div",
    {
      ...m,
      "data-panel": !0,
      "data-testid": f,
      id: f,
      ref: v,
      style: {
        ...Et,
        flexBasis: 0,
        flexGrow: `var(${L}, 1)`,
        flexShrink: 1,
        // Prevent Panel content from interfering with panel size
        overflow: "hidden",
        // Disable pointer events inside of a panel during resize
        // This avoid edge cases like nested iframes
        pointerEvents: `var(${Fe})`
      },
      children: /* @__PURE__ */ K(
        "div",
        {
          className: t,
          style: {
            width: "100%",
            height: "100%",
            ...h
          },
          children: e
        }
      )
    }
  );
}
const Et = {
  minHeight: "unset",
  maxHeight: "unset",
  height: "unset",
  minWidth: "unset",
  maxWidth: "unset",
  width: "unset",
  flex: "unset",
  flexBasis: "unset",
  flexShrink: "unset",
  flexGrow: "unset",
  border: "unset",
  borderWidth: "unset",
  padding: "unset",
  margin: "unset"
};
function At() {
  return I(null);
}
function Nt() {
  return O(null);
}
function Mt({
  layout: e,
  panelConstraints: t,
  panelId: n,
  panelIndex: o
}) {
  let r, a;
  const l = e[n], i = t.find(
    (s) => s.panelId === n
  );
  if (i) {
    const s = i.maxSize, u = a = i.collapsible ? i.collapsedSize : i.minSize, c = [o, o + 1];
    a = A({
      layout: Y({
        delta: u - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: c,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n], r = A({
      layout: Y({
        delta: s - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: c,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n];
  }
  return {
    valueControls: n,
    valueMax: r,
    valueMin: a,
    valueNow: l
  };
}
function $t({
  children: e,
  className: t,
  elementRef: n,
  id: o,
  style: r,
  ...a
}) {
  const l = ue(o), [i, s] = I({}), [u, c] = I("inactive"), [h, m] = I(null), p = fe(m, n), {
    id: f,
    orientation: d,
    registerSeparator: g
  } = de(), v = d === "horizontal" ? "vertical" : "horizontal";
  return N(() => {
    if (h !== null) {
      const S = {
        element: h,
        id: l
      }, x = g(S), y = _.addListener(
        "interactionStateChange",
        (L) => {
          c(
            L.state !== "inactive" && L.hitRegions.some(
              (C) => C.separator === S
            ) ? L.state : "inactive"
          );
        }
      ), b = _.addListener(
        "mountedGroupsChange",
        (L) => {
          L.forEach(
            ({ derivedPanelConstraints: C, layout: q, separatorToPanels: Z }, J) => {
              if (J.id === f) {
                const Q = Z.get(S);
                if (Q) {
                  const $ = Q[0], V = J.panels.indexOf($);
                  s(
                    Mt({
                      layout: q,
                      panelConstraints: C,
                      panelId: $.id,
                      panelIndex: V
                    })
                  );
                }
              }
            }
          );
        }
      );
      return () => {
        y(), b(), x();
      };
    }
  }, [h, f, l, g]), /* @__PURE__ */ K(
    "div",
    {
      ...a,
      "aria-controls": i.valueControls,
      "aria-orientation": v,
      "aria-valuemax": i.valueMax,
      "aria-valuemin": i.valueMin,
      "aria-valuenow": i.valueNow,
      children: e,
      className: t,
      "data-separator": u,
      "data-testid": l,
      id: l,
      ref: p,
      role: "separator",
      style: {
        flexBasis: "auto",
        ...r,
        flexGrow: 0,
        flexShrink: 0
      },
      tabIndex: 0
    }
  );
}
export {
  Gt as Group,
  _t as Panel,
  $t as Separator,
  Dt as useDefaultLayout,
  Ot as useGroupCallbackRef,
  Tt as useGroupRef,
  At as usePanelCallbackRef,
  Nt as usePanelRef
};
//# sourceMappingURL=react-resizable-panels.js.map
