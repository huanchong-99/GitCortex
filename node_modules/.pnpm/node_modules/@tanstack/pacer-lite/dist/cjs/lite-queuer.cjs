"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
class LiteQueuer {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.options = options;
    this.items = [];
    this.timeoutId = null;
    this.isRunning = true;
    this.pendingTick = false;
    this.addItem = (item, position = this.options.addItemsTo, startProcessing = true) => {
      if (this.items.length >= this.options.maxSize) {
        return false;
      }
      if (this.options.getPriority) {
        const priority = this.options.getPriority(item);
        if (priority !== void 0) {
          const insertIndex = this.items.findIndex((existing) => {
            const existingPriority = this.options.getPriority(existing);
            const effectivePriority = existingPriority ?? -Infinity;
            return effectivePriority < priority;
          });
          if (insertIndex === -1) {
            this.items.push(item);
          } else {
            this.items.splice(insertIndex, 0, item);
          }
        } else {
          this.insertAtPosition(item, position);
        }
      } else {
        this.insertAtPosition(item, position);
      }
      if (startProcessing && this.isRunning && !this.pendingTick) {
        this.tick();
      }
      return true;
    };
    this.insertAtPosition = (item, position) => {
      if (position === "front") {
        this.items.unshift(item);
      } else {
        this.items.push(item);
      }
    };
    this.getNextItem = (position = this.options.getItemsFrom) => {
      if (this.items.length === 0) {
        return void 0;
      }
      let item;
      if (this.options.getPriority || position === "front") {
        item = this.items.shift();
      } else {
        item = this.items.pop();
      }
      return item;
    };
    this.execute = (position) => {
      const item = this.getNextItem(position);
      if (item !== void 0) {
        this.fn(item);
      }
      return item;
    };
    this.tick = () => {
      if (!this.isRunning) {
        this.pendingTick = false;
        return;
      }
      this.pendingTick = true;
      while (this.items.length > 0) {
        const item = this.execute(this.options.getItemsFrom);
        if (item === void 0) {
          break;
        }
        const wait = this.options.wait;
        if (wait > 0) {
          this.timeoutId = setTimeout(() => this.tick(), wait);
          return;
        }
      }
      this.pendingTick = false;
    };
    this.start = () => {
      this.isRunning = true;
      if (!this.pendingTick && this.items.length > 0) {
        this.tick();
      }
    };
    this.stop = () => {
      this.clearTimeout();
      this.isRunning = false;
      this.pendingTick = false;
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    };
    this.peekNextItem = (position = "front") => {
      if (this.items.length === 0) {
        return void 0;
      }
      if (this.options.getPriority || position === "front") {
        return this.items[0];
      } else {
        return this.items[this.items.length - 1];
      }
    };
    this.peekAllItems = () => {
      return [...this.items];
    };
    this.flush = (numberOfItems = this.items.length, position) => {
      this.clearTimeout();
      for (let i = 0; i < numberOfItems && this.items.length > 0; i++) {
        this.execute(position);
      }
      if (this.isRunning && this.items.length > 0 && !this.pendingTick) {
        this.tick();
      }
    };
    this.flushAsBatch = (batchFunction) => {
      const items = this.peekAllItems();
      this.clear();
      batchFunction(items);
    };
    this.clear = () => {
      this.items = [];
    };
    this.options.addItemsTo = this.options.addItemsTo ?? "back";
    this.options.getItemsFrom = this.options.getItemsFrom ?? "front";
    this.options.maxSize = this.options.maxSize ?? Infinity;
    this.options.started = this.options.started ?? true;
    this.options.wait = this.options.wait ?? 0;
    this.isRunning = this.options.started;
    if (this.options.initialItems) {
      for (const item of this.options.initialItems) {
        this.addItem(item, this.options.addItemsTo, false);
      }
    }
    if (this.isRunning && this.items.length > 0) {
      this.tick();
    }
  }
  /**
   * Number of items currently in the queue
   */
  get size() {
    return this.items.length;
  }
  /**
   * Whether the queue is empty
   */
  get isEmpty() {
    return this.items.length === 0;
  }
  /**
   * Whether the queue is currently running (auto-processing items)
   */
  get isQueueRunning() {
    return this.isRunning;
  }
}
function liteQueue(fn, options = {}) {
  const queuer = new LiteQueuer(fn, options);
  return (item) => queuer.addItem(item);
}
exports.LiteQueuer = LiteQueuer;
exports.liteQueue = liteQueue;
//# sourceMappingURL=lite-queuer.cjs.map
