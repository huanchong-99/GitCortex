"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
class LiteDebouncer {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.canLeadingExecute = true;
    this.maybeExecute = (...args) => {
      let didLeadingExecute = false;
      if (this.options.leading && this.canLeadingExecute) {
        this.canLeadingExecute = false;
        didLeadingExecute = true;
        this.fn(...args);
        this.options.onExecute?.(args, this);
      }
      this.lastArgs = args;
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }
      this.timeoutId = setTimeout(() => {
        this.canLeadingExecute = true;
        if (this.options.trailing && !didLeadingExecute && this.lastArgs) {
          this.fn(...this.lastArgs);
          this.options.onExecute?.(this.lastArgs, this);
        }
        this.lastArgs = void 0;
      }, this.options.wait);
    };
    this.flush = () => {
      if (this.timeoutId && this.lastArgs) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
        const args = this.lastArgs;
        this.fn(...args);
        this.options.onExecute?.(args, this);
        this.lastArgs = void 0;
        this.canLeadingExecute = true;
      }
    };
    this.cancel = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = void 0;
      }
      this.lastArgs = void 0;
      this.canLeadingExecute = true;
    };
    if (this.options.leading === void 0 && this.options.trailing === void 0) {
      this.options.trailing = true;
    }
  }
}
function liteDebounce(fn, options) {
  const debouncer = new LiteDebouncer(fn, options);
  return debouncer.maybeExecute;
}
exports.LiteDebouncer = LiteDebouncer;
exports.liteDebounce = liteDebounce;
//# sourceMappingURL=lite-debouncer.cjs.map
