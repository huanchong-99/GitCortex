"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
class LiteRateLimiter {
  constructor(fn, options) {
    this.fn = fn;
    this.options = options;
    this.executionTimes = [];
    this.timeoutIds = /* @__PURE__ */ new Set();
    this.maybeExecute = (...args) => {
      this.cleanupOldExecutions();
      const relevantExecutionTimes = this.getExecutionTimesInWindow();
      if (relevantExecutionTimes.length < this.options.limit) {
        this.execute(...args);
        return true;
      }
      this.options.onReject?.(this);
      return false;
    };
    this.execute = (...args) => {
      const now = Date.now();
      this.fn(...args);
      this.options.onExecute?.(args, this);
      this.executionTimes.push(now);
      this.setCleanupTimeout(now);
    };
    this.getExecutionTimesInWindow = () => {
      if (this.options.windowType === "sliding") {
        return this.executionTimes.filter(
          (time) => time > Date.now() - this.options.window
        );
      } else {
        if (this.executionTimes.length === 0) {
          return [];
        }
        const oldestExecution = Math.min(...this.executionTimes);
        const windowStart = oldestExecution;
        const windowEnd = windowStart + this.options.window;
        const now = Date.now();
        if (now > windowEnd) {
          return [];
        }
        return this.executionTimes.filter(
          (time) => time >= windowStart && time <= windowEnd
        );
      }
    };
    this.setCleanupTimeout = (executionTime) => {
      if (this.options.windowType === "sliding" || this.timeoutIds.size === 0) {
        const now = Date.now();
        const timeUntilExpiration = executionTime - now + this.options.window + 1;
        const timeoutId = setTimeout(() => {
          this.cleanupOldExecutions();
          this.clearTimeout(timeoutId);
        }, timeUntilExpiration);
        this.timeoutIds.add(timeoutId);
      }
    };
    this.clearTimeout = (timeoutId) => {
      clearTimeout(timeoutId);
      this.timeoutIds.delete(timeoutId);
    };
    this.clearTimeouts = () => {
      this.timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
      this.timeoutIds.clear();
    };
    this.cleanupOldExecutions = () => {
      this.executionTimes = this.getExecutionTimesInWindow();
    };
    this.getRemainingInWindow = () => {
      const relevantExecutionTimes = this.getExecutionTimesInWindow();
      return Math.max(0, this.options.limit - relevantExecutionTimes.length);
    };
    this.getMsUntilNextWindow = () => {
      if (this.getRemainingInWindow() > 0) {
        return 0;
      }
      const oldestExecution = this.executionTimes[0] ?? Infinity;
      return oldestExecution + this.options.window - Date.now();
    };
    this.reset = () => {
      this.executionTimes = [];
      this.clearTimeouts();
    };
    if (this.options.windowType === void 0) {
      this.options.windowType = "fixed";
    }
  }
}
function liteRateLimit(fn, options) {
  const rateLimiter = new LiteRateLimiter(fn, options);
  return rateLimiter.maybeExecute;
}
exports.LiteRateLimiter = LiteRateLimiter;
exports.liteRateLimit = liteRateLimit;
//# sourceMappingURL=lite-rate-limiter.cjs.map
