{"version":3,"file":"lite-rate-limiter.cjs","sources":["../../src/lite-rate-limiter.ts"],"sourcesContent":["import type { AnyFunction } from '@tanstack/pacer/types'\n\n/**\n * Options for configuring a lite rate-limited function\n */\nexport interface LiteRateLimiterOptions<TFn extends AnyFunction = AnyFunction> {\n  /**\n   * Maximum number of executions allowed within the time window.\n   */\n  limit: number\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, rateLimiter: LiteRateLimiter<TFn>) => void\n  /**\n   * Optional callback function that is called when an execution is rejected due to rate limiting\n   */\n  onReject?: (rateLimiter: LiteRateLimiter<TFn>) => void\n  /**\n   * Time window in milliseconds within which the limit applies.\n   */\n  window: number\n  /**\n   * Type of window to use for rate limiting\n   * - 'fixed': Uses a fixed window that resets after the window period\n   * - 'sliding': Uses a sliding window that allows executions as old ones expire\n   * Defaults to 'fixed'\n   */\n  windowType?: 'fixed' | 'sliding'\n}\n\n/**\n * A lightweight class that creates a rate-limited function.\n *\n * This is an alternative to the RateLimiter in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core RateLimiter,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * and provides only essential rate limiting functionality.\n *\n * Rate limiting allows a function to execute up to a limit within a time window,\n * then blocks all subsequent calls until the window passes. This can lead to \"bursty\" behavior where\n * all executions happen immediately, followed by a complete block.\n *\n * The rate limiter supports two types of windows:\n * - 'fixed': A strict window that resets after the window period. All executions within the window count\n *   towards the limit, and the window resets completely after the period.\n * - 'sliding': A rolling window that allows executions as old ones expire. This provides a more\n *   consistent rate of execution over time.\n *\n * Features:\n * - Zero dependencies - no external libraries required\n * - Minimal API surface - only essential methods (maybeExecute, getRemainingInWindow, getMsUntilNextWindow, reset)\n * - Simple state management - uses basic private properties instead of reactive stores\n * - Lightweight - designed for use in npm packages where bundle size matters\n *\n * @example\n * ```ts\n * const rateLimiter = new LiteRateLimiter((id: string) => {\n *   api.getData(id);\n * }, { limit: 5, window: 1000 });\n *\n * // First 5 calls will execute, then block until window resets\n * if (rateLimiter.maybeExecute('123')) {\n *   console.log('API call made');\n * } else {\n *   console.log('Rate limited - try again in', rateLimiter.getMsUntilNextWindow(), 'ms');\n * }\n * ```\n */\nexport class LiteRateLimiter<TFn extends AnyFunction> {\n  private executionTimes: Array<number> = []\n  private timeoutIds: Set<NodeJS.Timeout> = new Set()\n\n  constructor(\n    public fn: TFn,\n    public options: LiteRateLimiterOptions<TFn>,\n  ) {\n    // Default windowType to 'fixed' if not specified\n    if (this.options.windowType === undefined) {\n      this.options.windowType = 'fixed'\n    }\n  }\n\n  /**\n   * Attempts to execute the rate-limited function if within the configured limits.\n   * Returns true if executed, false if rejected due to rate limiting.\n   *\n   * @example\n   * ```ts\n   * const rateLimiter = new LiteRateLimiter(fn, { limit: 5, window: 1000 });\n   *\n   * // First 5 calls return true\n   * rateLimiter.maybeExecute('arg1', 'arg2'); // true\n   *\n   * // Additional calls within the window return false\n   * rateLimiter.maybeExecute('arg1', 'arg2'); // false\n   * ```\n   */\n  maybeExecute = (...args: Parameters<TFn>): boolean => {\n    this.cleanupOldExecutions()\n\n    const relevantExecutionTimes = this.getExecutionTimesInWindow()\n\n    if (relevantExecutionTimes.length < this.options.limit) {\n      this.execute(...args)\n      return true\n    }\n\n    this.options.onReject?.(this)\n    return false\n  }\n\n  private execute = (...args: Parameters<TFn>): void => {\n    const now = Date.now()\n    this.fn(...args)\n    this.options.onExecute?.(args, this)\n    this.executionTimes.push(now)\n    this.setCleanupTimeout(now)\n  }\n\n  private getExecutionTimesInWindow = (): Array<number> => {\n    if (this.options.windowType === 'sliding') {\n      // For sliding window, return all executions within the current window\n      return this.executionTimes.filter(\n        (time) => time > Date.now() - this.options.window,\n      )\n    } else {\n      // For fixed window, return all executions in the current window\n      if (this.executionTimes.length === 0) {\n        return []\n      }\n      const oldestExecution = Math.min(...this.executionTimes)\n      const windowStart = oldestExecution\n      const windowEnd = windowStart + this.options.window\n      const now = Date.now()\n\n      // If the window has expired, return empty array\n      if (now > windowEnd) {\n        return []\n      }\n\n      // Otherwise, return all executions in the current window\n      return this.executionTimes.filter(\n        (time) => time >= windowStart && time <= windowEnd,\n      )\n    }\n  }\n\n  private setCleanupTimeout = (executionTime: number): void => {\n    if (\n      this.options.windowType === 'sliding' ||\n      this.timeoutIds.size === 0 // new fixed window\n    ) {\n      const now = Date.now()\n      const timeUntilExpiration = executionTime - now + this.options.window + 1\n      const timeoutId = setTimeout(() => {\n        this.cleanupOldExecutions()\n        this.clearTimeout(timeoutId)\n      }, timeUntilExpiration)\n      this.timeoutIds.add(timeoutId)\n    }\n  }\n\n  private clearTimeout = (timeoutId: NodeJS.Timeout): void => {\n    clearTimeout(timeoutId)\n    this.timeoutIds.delete(timeoutId)\n  }\n\n  private clearTimeouts = (): void => {\n    this.timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId))\n    this.timeoutIds.clear()\n  }\n\n  private cleanupOldExecutions = (): void => {\n    this.executionTimes = this.getExecutionTimesInWindow()\n  }\n\n  /**\n   * Returns the number of remaining executions allowed in the current window.\n   */\n  getRemainingInWindow = (): number => {\n    const relevantExecutionTimes = this.getExecutionTimesInWindow()\n    return Math.max(0, this.options.limit - relevantExecutionTimes.length)\n  }\n\n  /**\n   * Returns the number of milliseconds until the next execution will be possible.\n   * Returns 0 if executions are currently allowed.\n   */\n  getMsUntilNextWindow = (): number => {\n    if (this.getRemainingInWindow() > 0) {\n      return 0\n    }\n    const oldestExecution = this.executionTimes[0] ?? Infinity\n    return oldestExecution + this.options.window - Date.now()\n  }\n\n  /**\n   * Resets the rate limiter state, clearing all execution history.\n   */\n  reset = (): void => {\n    this.executionTimes = []\n    this.clearTimeouts()\n  }\n}\n\n/**\n * Creates a lightweight rate-limited function that will execute the provided function up to a maximum number of times within a time window.\n *\n * This is an alternative to the rateLimit function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a rate limiter with no external dependencies, devtools integration, or reactive state.\n *\n * Rate limiting allows all executions until the limit is reached, then blocks all subsequent calls until the window resets.\n * This differs from throttling (which ensures even spacing) and debouncing (which waits for pauses).\n *\n * @example\n * ```ts\n * const rateLimitedApi = liteRateLimit(makeApiCall, {\n *   limit: 5,\n *   window: 60000, // 1 minute\n *   windowType: 'sliding'\n * });\n *\n * // First 5 calls execute immediately\n * // Additional calls are rejected until window allows\n * rateLimitedApi();\n * ```\n *\n * @example\n * ```ts\n * // Fixed window - all 10 calls happen in first second, then 10 second wait\n * const rateLimitedFixed = liteRateLimit(logEvent, {\n *   limit: 10,\n *   window: 10000,\n *   windowType: 'fixed'\n * });\n * ```\n */\nexport function liteRateLimit<TFn extends AnyFunction>(\n  fn: TFn,\n  options: LiteRateLimiterOptions<TFn>,\n): (...args: Parameters<TFn>) => boolean {\n  const rateLimiter = new LiteRateLimiter(fn, options)\n  return rateLimiter.maybeExecute\n}\n"],"names":[],"mappings":";;AAqEO,MAAM,gBAAyC;AAAA,EAIpD,YACS,IACA,SACP;AAFO,SAAA,KAAA;AACA,SAAA,UAAA;AALT,SAAQ,iBAAgC,CAAA;AACxC,SAAQ,iCAAsC,IAAA;AA2B9C,SAAA,eAAe,IAAI,SAAmC;AACpD,WAAK,qBAAA;AAEL,YAAM,yBAAyB,KAAK,0BAAA;AAEpC,UAAI,uBAAuB,SAAS,KAAK,QAAQ,OAAO;AACtD,aAAK,QAAQ,GAAG,IAAI;AACpB,eAAO;AAAA,MACT;AAEA,WAAK,QAAQ,WAAW,IAAI;AAC5B,aAAO;AAAA,IACT;AAEA,SAAQ,UAAU,IAAI,SAAgC;AACpD,YAAM,MAAM,KAAK,IAAA;AACjB,WAAK,GAAG,GAAG,IAAI;AACf,WAAK,QAAQ,YAAY,MAAM,IAAI;AACnC,WAAK,eAAe,KAAK,GAAG;AAC5B,WAAK,kBAAkB,GAAG;AAAA,IAC5B;AAEA,SAAQ,4BAA4B,MAAqB;AACvD,UAAI,KAAK,QAAQ,eAAe,WAAW;AAEzC,eAAO,KAAK,eAAe;AAAA,UACzB,CAAC,SAAS,OAAO,KAAK,IAAA,IAAQ,KAAK,QAAQ;AAAA,QAAA;AAAA,MAE/C,OAAO;AAEL,YAAI,KAAK,eAAe,WAAW,GAAG;AACpC,iBAAO,CAAA;AAAA,QACT;AACA,cAAM,kBAAkB,KAAK,IAAI,GAAG,KAAK,cAAc;AACvD,cAAM,cAAc;AACpB,cAAM,YAAY,cAAc,KAAK,QAAQ;AAC7C,cAAM,MAAM,KAAK,IAAA;AAGjB,YAAI,MAAM,WAAW;AACnB,iBAAO,CAAA;AAAA,QACT;AAGA,eAAO,KAAK,eAAe;AAAA,UACzB,CAAC,SAAS,QAAQ,eAAe,QAAQ;AAAA,QAAA;AAAA,MAE7C;AAAA,IACF;AAEA,SAAQ,oBAAoB,CAAC,kBAAgC;AAC3D,UACE,KAAK,QAAQ,eAAe,aAC5B,KAAK,WAAW,SAAS,GACzB;AACA,cAAM,MAAM,KAAK,IAAA;AACjB,cAAM,sBAAsB,gBAAgB,MAAM,KAAK,QAAQ,SAAS;AACxE,cAAM,YAAY,WAAW,MAAM;AACjC,eAAK,qBAAA;AACL,eAAK,aAAa,SAAS;AAAA,QAC7B,GAAG,mBAAmB;AACtB,aAAK,WAAW,IAAI,SAAS;AAAA,MAC/B;AAAA,IACF;AAEA,SAAQ,eAAe,CAAC,cAAoC;AAC1D,mBAAa,SAAS;AACtB,WAAK,WAAW,OAAO,SAAS;AAAA,IAClC;AAEA,SAAQ,gBAAgB,MAAY;AAClC,WAAK,WAAW,QAAQ,CAAC,cAAc,aAAa,SAAS,CAAC;AAC9D,WAAK,WAAW,MAAA;AAAA,IAClB;AAEA,SAAQ,uBAAuB,MAAY;AACzC,WAAK,iBAAiB,KAAK,0BAAA;AAAA,IAC7B;AAKA,SAAA,uBAAuB,MAAc;AACnC,YAAM,yBAAyB,KAAK,0BAAA;AACpC,aAAO,KAAK,IAAI,GAAG,KAAK,QAAQ,QAAQ,uBAAuB,MAAM;AAAA,IACvE;AAMA,SAAA,uBAAuB,MAAc;AACnC,UAAI,KAAK,qBAAA,IAAyB,GAAG;AACnC,eAAO;AAAA,MACT;AACA,YAAM,kBAAkB,KAAK,eAAe,CAAC,KAAK;AAClD,aAAO,kBAAkB,KAAK,QAAQ,SAAS,KAAK,IAAA;AAAA,IACtD;AAKA,SAAA,QAAQ,MAAY;AAClB,WAAK,iBAAiB,CAAA;AACtB,WAAK,cAAA;AAAA,IACP;AA7HE,QAAI,KAAK,QAAQ,eAAe,QAAW;AACzC,WAAK,QAAQ,aAAa;AAAA,IAC5B;AAAA,EACF;AA2HF;AAmCO,SAAS,cACd,IACA,SACuC;AACvC,QAAM,cAAc,IAAI,gBAAgB,IAAI,OAAO;AACnD,SAAO,YAAY;AACrB;;;"}