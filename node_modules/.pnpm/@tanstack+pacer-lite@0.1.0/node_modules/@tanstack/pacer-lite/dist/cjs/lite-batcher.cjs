"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
class LiteBatcher {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.options = options;
    this.items = [];
    this.timeoutId = null;
    this._isPending = false;
    this.addItem = (item) => {
      this.items.push(item);
      this._isPending = this.options.wait !== Infinity;
      this.options.onItemsChange?.(this);
      const shouldProcess = this.items.length >= this.options.maxSize || this.options.getShouldExecute(this.items, this);
      if (shouldProcess) {
        this.execute();
      } else if (this.options.wait !== Infinity) {
        this.clearTimeout();
        this.timeoutId = setTimeout(() => this.execute(), this.getWait());
      }
    };
    this.execute = () => {
      if (this.items.length === 0) {
        return;
      }
      const batch = this.peekAllItems();
      this.clear();
      this.fn(batch);
      this.options.onExecute?.(batch, this);
    };
    this.flush = () => {
      this.clearTimeout();
      this.execute();
    };
    this.peekAllItems = () => {
      return [...this.items];
    };
    this.clearTimeout = () => {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    };
    this.clear = () => {
      const hadItems = this.items.length > 0;
      this.items = [];
      this._isPending = false;
      if (hadItems) {
        this.options.onItemsChange?.(this);
      }
    };
    this.cancel = () => {
      this.clearTimeout();
      this._isPending = false;
    };
    this.options.maxSize = this.options.maxSize ?? Infinity;
    this.options.started = this.options.started ?? true;
    this.options.wait = this.options.wait ?? Infinity;
    this.options.getShouldExecute = this.options.getShouldExecute ?? (() => false);
  }
  /**
   * Number of items currently in the batch
   */
  get size() {
    return this.items.length;
  }
  /**
   * Whether the batch has no items to process (items array is empty)
   */
  get isEmpty() {
    return this.items.length === 0;
  }
  /**
   * Whether the batcher is waiting for the timeout to trigger batch processing
   */
  get isPending() {
    return this._isPending;
  }
  getWait() {
    if (typeof this.options.wait === "function") {
      return this.options.wait(this);
    }
    return this.options.wait;
  }
}
function liteBatch(fn, options = {}) {
  const batcher = new LiteBatcher(fn, options);
  return batcher.addItem;
}
exports.LiteBatcher = LiteBatcher;
exports.liteBatch = liteBatch;
//# sourceMappingURL=lite-batcher.cjs.map
