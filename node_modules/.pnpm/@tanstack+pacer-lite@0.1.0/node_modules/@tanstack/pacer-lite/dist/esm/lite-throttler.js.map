{"version":3,"file":"lite-throttler.js","sources":["../../src/lite-throttler.ts"],"sourcesContent":["import type { AnyFunction } from '@tanstack/pacer/types'\n\n/**\n * Options for configuring a lite throttled function\n */\nexport interface LiteThrottlerOptions<TFn extends AnyFunction = AnyFunction> {\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * Defaults to true.\n   */\n  leading?: boolean\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, throttler: LiteThrottler<TFn>) => void\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Time window in milliseconds during which the function can only be executed once.\n   */\n  wait: number\n}\n\n/**\n * A lightweight class that creates a throttled function.\n *\n * This is an alternative to the Throttler in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core Throttler,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * and provides only essential throttling functionality.\n *\n * Throttling ensures a function is called at most once within a specified time window.\n * Unlike debouncing which waits for a pause in calls, throttling guarantees consistent\n * execution timing regardless of call frequency.\n *\n * Supports both leading and trailing edge execution:\n * - Leading: Execute immediately on first call (default: true)\n * - Trailing: Execute after wait period if called during throttle (default: true)\n *\n * Features:\n * - Zero dependencies - no external libraries required\n * - Minimal API surface - only essential methods (maybeExecute, flush, cancel)\n * - Simple state management - uses basic private properties instead of reactive stores\n * - Callback support for monitoring execution events\n * - Lightweight - designed for use in npm packages where bundle size matters\n *\n * @example\n * ```ts\n * const throttler = new LiteThrottler((scrollY: number) => {\n *   updateScrollPosition(scrollY);\n * }, {\n *   wait: 100,\n *   onExecute: (args, throttler) => {\n *     console.log('Updated scroll position:', args[0]);\n *   }\n * });\n *\n * // Will execute at most once per 100ms\n * window.addEventListener('scroll', () => {\n *   throttler.maybeExecute(window.scrollY);\n * });\n * ```\n */\nexport class LiteThrottler<TFn extends AnyFunction> {\n  private timeoutId: NodeJS.Timeout | undefined\n  private lastArgs: Parameters<TFn> | undefined\n  private lastExecutionTime = 0\n  private isPending = false\n\n  constructor(\n    public fn: TFn,\n    public options: LiteThrottlerOptions<TFn>,\n  ) {\n    // Default both leading and trailing to true if neither is specified\n    if (\n      this.options.leading === undefined &&\n      this.options.trailing === undefined\n    ) {\n      this.options.leading = true\n      this.options.trailing = true\n    }\n  }\n\n  /**\n   * Attempts to execute the throttled function. The execution behavior depends on the throttler options:\n   *\n   * - If enough time has passed since the last execution (>= wait period):\n   *   - With leading=true: Executes immediately\n   *   - With leading=false: Waits for the next trailing execution\n   *\n   * - If within the wait period:\n   *   - With trailing=true: Schedules execution for end of wait period\n   *   - With trailing=false: Drops the execution\n   */\n  maybeExecute = (...args: Parameters<TFn>): void => {\n    const now = Date.now()\n    const timeSinceLastExecution = now - this.lastExecutionTime\n\n    // Handle leading execution\n    if (this.options.leading && timeSinceLastExecution >= this.options.wait) {\n      this.execute(...args)\n    } else {\n      // Store the most recent arguments for potential trailing execution\n      this.lastArgs = args\n\n      // Set up trailing execution if not already scheduled\n      if (!this.timeoutId && this.options.trailing) {\n        const timeoutDuration = this.options.wait - timeSinceLastExecution\n        this.isPending = true\n        this.timeoutId = setTimeout(() => {\n          if (this.lastArgs !== undefined) {\n            this.execute(...this.lastArgs)\n          }\n        }, timeoutDuration)\n      }\n    }\n  }\n\n  private execute = (...args: Parameters<TFn>): void => {\n    this.fn(...args)\n    this.options.onExecute?.(args, this)\n    this.lastExecutionTime = Date.now()\n    this.clearTimeout()\n    this.lastArgs = undefined\n    this.isPending = false\n  }\n\n  /**\n   * Processes the current pending execution immediately.\n   * If there's a pending execution, it will be executed right away\n   * and the timeout will be cleared.\n   */\n  flush = (): void => {\n    if (this.isPending && this.lastArgs) {\n      this.execute(...this.lastArgs)\n    }\n  }\n\n  /**\n   * Cancels any pending trailing execution and clears internal state.\n   * If a trailing execution is scheduled, this will prevent that execution from occurring.\n   */\n  cancel = (): void => {\n    this.clearTimeout()\n    this.lastArgs = undefined\n    this.isPending = false\n  }\n\n  private clearTimeout = (): void => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = undefined\n    }\n  }\n}\n\n/**\n * Creates a lightweight throttled function that limits how often the provided function can execute.\n *\n * This is an alternative to the throttle function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a throttler with no external dependencies, devtools integration, or reactive state.\n *\n * Throttling ensures a function executes at most once within a specified time window,\n * regardless of how many times it is called. This is useful for rate-limiting\n * expensive operations or UI updates.\n *\n * @example\n * ```ts\n * const throttledScroll = liteThrottle(() => {\n *   updateScrollIndicator();\n * }, { wait: 100 });\n *\n * // Will execute at most once per 100ms\n * window.addEventListener('scroll', throttledScroll);\n * ```\n *\n * @example\n * ```ts\n * // Leading edge execution - fires immediately then throttles\n * const throttledResize = liteThrottle(() => {\n *   recalculateLayout();\n * }, { wait: 250, leading: true, trailing: false });\n * ```\n */\nexport function liteThrottle<TFn extends AnyFunction>(\n  fn: TFn,\n  options: LiteThrottlerOptions<TFn>,\n): (...args: Parameters<TFn>) => void {\n  const throttler = new LiteThrottler(fn, options)\n  return throttler.maybeExecute\n}\n"],"names":[],"mappings":"AAkEO,MAAM,cAAuC;AAAA,EAMlD,YACS,IACA,SACP;AAFO,SAAA,KAAA;AACA,SAAA,UAAA;AALT,SAAQ,oBAAoB;AAC5B,SAAQ,YAAY;AA2BpB,SAAA,eAAe,IAAI,SAAgC;AACjD,YAAM,MAAM,KAAK,IAAA;AACjB,YAAM,yBAAyB,MAAM,KAAK;AAG1C,UAAI,KAAK,QAAQ,WAAW,0BAA0B,KAAK,QAAQ,MAAM;AACvE,aAAK,QAAQ,GAAG,IAAI;AAAA,MACtB,OAAO;AAEL,aAAK,WAAW;AAGhB,YAAI,CAAC,KAAK,aAAa,KAAK,QAAQ,UAAU;AAC5C,gBAAM,kBAAkB,KAAK,QAAQ,OAAO;AAC5C,eAAK,YAAY;AACjB,eAAK,YAAY,WAAW,MAAM;AAChC,gBAAI,KAAK,aAAa,QAAW;AAC/B,mBAAK,QAAQ,GAAG,KAAK,QAAQ;AAAA,YAC/B;AAAA,UACF,GAAG,eAAe;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAEA,SAAQ,UAAU,IAAI,SAAgC;AACpD,WAAK,GAAG,GAAG,IAAI;AACf,WAAK,QAAQ,YAAY,MAAM,IAAI;AACnC,WAAK,oBAAoB,KAAK,IAAA;AAC9B,WAAK,aAAA;AACL,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAOA,SAAA,QAAQ,MAAY;AAClB,UAAI,KAAK,aAAa,KAAK,UAAU;AACnC,aAAK,QAAQ,GAAG,KAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAMA,SAAA,SAAS,MAAY;AACnB,WAAK,aAAA;AACL,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAEA,SAAQ,eAAe,MAAY;AACjC,UAAI,KAAK,WAAW;AAClB,qBAAa,KAAK,SAAS;AAC3B,aAAK,YAAY;AAAA,MACnB;AAAA,IACF;AA/EE,QACE,KAAK,QAAQ,YAAY,UACzB,KAAK,QAAQ,aAAa,QAC1B;AACA,WAAK,QAAQ,UAAU;AACvB,WAAK,QAAQ,WAAW;AAAA,IAC1B;AAAA,EACF;AAyEF;AA+BO,SAAS,aACd,IACA,SACoC;AACpC,QAAM,YAAY,IAAI,cAAc,IAAI,OAAO;AAC/C,SAAO,UAAU;AACnB;"}