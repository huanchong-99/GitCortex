import { orderByWithFractionalIndex } from "@tanstack/db-ivm";
import { makeComparator, defaultComparator } from "../../utils/comparison.js";
import { followRef, PropRef } from "../ir.js";
import { ensureIndexForField } from "../../indexes/auto-index.js";
import { findIndexForField } from "../../utils/index-optimization.js";
import { compileExpression } from "./evaluators.js";
import { replaceAggregatesByRefs } from "./group-by.js";
function processOrderBy(rawQuery, pipeline, orderByClause, selectClause, collection, optimizableOrderByCollections, setWindowFn, limit, offset) {
  const compiledOrderBy = orderByClause.map((clause) => {
    const clauseWithoutAggregates = replaceAggregatesByRefs(
      clause.expression,
      selectClause,
      `__select_results`
    );
    return {
      compiledExpression: compileExpression(clauseWithoutAggregates),
      compareOptions: buildCompareOptions(clause, collection)
    };
  });
  const valueExtractor = (row) => {
    const orderByContext = row;
    if (orderByClause.length > 1) {
      return compiledOrderBy.map(
        (compiled) => compiled.compiledExpression(orderByContext)
      );
    } else if (orderByClause.length === 1) {
      const compiled = compiledOrderBy[0];
      return compiled.compiledExpression(orderByContext);
    }
    return null;
  };
  const compare = (a, b) => {
    if (orderByClause.length > 1) {
      const arrayA = a;
      const arrayB = b;
      for (let i = 0; i < orderByClause.length; i++) {
        const clause = compiledOrderBy[i];
        const compareFn = makeComparator(clause.compareOptions);
        const result = compareFn(arrayA[i], arrayB[i]);
        if (result !== 0) {
          return result;
        }
      }
      return arrayA.length - arrayB.length;
    }
    if (orderByClause.length === 1) {
      const clause = compiledOrderBy[0];
      const compareFn = makeComparator(clause.compareOptions);
      return compareFn(a, b);
    }
    return defaultComparator(a, b);
  };
  let setSizeCallback;
  let orderByOptimizationInfo;
  if (limit && orderByClause.length === 1) {
    const clause = orderByClause[0];
    const orderByExpression = clause.expression;
    if (orderByExpression.type === `ref`) {
      const followRefResult = followRef(
        rawQuery,
        orderByExpression,
        collection
      );
      const followRefCollection = followRefResult.collection;
      const fieldName = followRefResult.path[0];
      const compareOpts = buildCompareOptions(clause, followRefCollection);
      if (fieldName) {
        ensureIndexForField(
          fieldName,
          followRefResult.path,
          followRefCollection,
          compareOpts,
          compare
        );
      }
      const valueExtractorForRawRow = compileExpression(
        new PropRef(followRefResult.path),
        true
      );
      const comparator = (a, b) => {
        const extractedA = a ? valueExtractorForRawRow(a) : a;
        const extractedB = b ? valueExtractorForRawRow(b) : b;
        return compare(extractedA, extractedB);
      };
      const index = findIndexForField(
        followRefCollection,
        followRefResult.path,
        compareOpts
      );
      if (index && index.supports(`gt`)) {
        const orderByAlias = orderByExpression.path.length > 1 ? String(orderByExpression.path[0]) : rawQuery.from.alias;
        orderByOptimizationInfo = {
          alias: orderByAlias,
          offset: offset ?? 0,
          limit,
          comparator,
          valueExtractorForRawRow,
          index,
          orderBy: orderByClause
        };
        optimizableOrderByCollections[followRefCollection.id] = orderByOptimizationInfo;
        setSizeCallback = (getSize) => {
          optimizableOrderByCollections[followRefCollection.id][`dataNeeded`] = () => {
            const size = getSize();
            return Math.max(0, orderByOptimizationInfo.limit - size);
          };
        };
      }
    }
  }
  return pipeline.pipe(
    orderByWithFractionalIndex(valueExtractor, {
      limit,
      offset,
      comparator: compare,
      setSizeCallback,
      setWindowFn: (windowFn) => {
        setWindowFn(
          // We wrap the move function such that we update the orderByOptimizationInfo
          // because that is used by the `dataNeeded` callback to determine if we need to load more data
          (options) => {
            windowFn(options);
            if (orderByOptimizationInfo) {
              orderByOptimizationInfo.offset = options.offset ?? orderByOptimizationInfo.offset;
              orderByOptimizationInfo.limit = options.limit ?? orderByOptimizationInfo.limit;
            }
          }
        );
      }
    })
    // orderByWithFractionalIndex returns [key, [value, index]] - we keep this format
  );
}
function buildCompareOptions(clause, collection) {
  if (clause.compareOptions.stringSort !== void 0) {
    return clause.compareOptions;
  }
  return {
    ...collection.compareOptions,
    direction: clause.compareOptions.direction,
    nulls: clause.compareOptions.nulls
  };
}
export {
  buildCompareOptions,
  processOrderBy
};
//# sourceMappingURL=order-by.js.map
